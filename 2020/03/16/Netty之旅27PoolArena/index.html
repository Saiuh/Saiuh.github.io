<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="我的个人博客"><title>Netty解析二十五：Netty内存分配PoolArena | SvizzerChow's Blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Netty解析二十五：Netty内存分配PoolArena</h1><a id="logo" href="/.">SvizzerChow's Blog</a><p class="description">Leaning</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Netty解析二十五：Netty内存分配PoolArena</h1><div class="post-meta">Mar 16, 2020<span> | </span><span class="category"><a href="/categories/Netty/">Netty</a></span></div><div class="post-content"><meta name="referrer" content="no-referrer">


<p>前面解析了PoolChunk、PoolSubpage和PoolChunkList的内容，接下来解析PoolArena。在之前解析的过程中可以发现PoolChunk、PoolSubpage和PoolChunkList都是被PoolArena管理着。<br><a id="more"></a></p>
<h2 id="PoolArena"><a href="#PoolArena" class="headerlink" title="PoolArena"></a>PoolArena</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>PoolArena是Netty内存管理的一个核心入口，它来统筹内存的分配。无论要分配多大的内存空间都从PoolArena#allocate(io.netty.buffer.PoolThreadCache, int, int)方法中分配。它返回的是PooledByteBuf，内存空间的包装类，将堆内存和jvm外内存进行统一管理。</p>
<p>PoolArena将需要分配的内存大小划分为Tiny、Small、Normal和Huge。</p>
<ul>
<li>Tiny:小于pageSize，并小于512字节</li>
<li>Small:小于pageSize</li>
<li>Normal:小于等于chunkSize</li>
<li>Huge:大于chunkSize</li>
</ul>
<p>PoolArena可以理解为一个管理器/调度器，PoolArena不直接管理内存区域，内存区域的管理交由PoolChunk来管理。PoolArena中会使用PoolChunkList链表将使用的Chunk进行管理，并根据使用率调节优先级。</p>
<p>PoolChunk是一大块内存空间，其总大小为chunkSize，PoolChunk是由一小块一小块的Page组合成的，这个组合是二叉树的结构。通过二叉树节点的标记可以处理不同内存的大小的使用。</p>
<p>但是Page的大小PageSize也是比较大的，当需要分配Tiny/Small大小的内存时，直接使用Page是比较浪费的，所以在Page之下还有Subpage，Subpage是Page按一定长度进行划分的区域，每块SubPage可能大小不一样。在Chunk第一次划分了Subpage后PoolArena会将该Subpage加入到对应大小的tinySubpagePools/smallSubpagePools数组中，下次需要分配相同大小的空间时可以直接使用数组定位，而不用通过Chunk再划分。</p>
<p>PooledByteBuf:内存分为堆内存和jvm外内存，Netty为了统一多种内存的操作将他们进行了封装，这就是ByteBuf。ByteBuf有个成员变量memory，它代表实际的内存空间，例如：byte[]或者ByteBuffer。</p>
<h3 id="继承关系以及成员变量"><a href="#继承关系以及成员变量" class="headerlink" title="继承关系以及成员变量"></a>继承关系以及成员变量</h3><p>PoolArena是一个抽象类，可以发现PoolChunk、PoolSubpage和PoolChunkList这三个类都不是抽象类，这是因为PoolArena作为内存块总的管理入口对内存类型进行了抽象，它有两个实现类：DirectArena、HeapArena。</p>
<p>PoolArena中也定义了内存块的大小：Tiny、Small和Normal。</p>
<p>PlatformDependent类是Netty中用于处理不同jdk版本的类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">PoolArena</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">PoolArenaMetric</span> </span>&#123;</span><br><span class="line">    <span class="comment">// jdk版本中是否有sun的unsafe类，unsafe类可用于内存操作</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> HAS_UNSAFE = PlatformDependent.hasUnsafe();</span><br><span class="line">    <span class="comment">// 定义了需要分配内存块的大小</span></span><br><span class="line">    <span class="keyword">enum</span> SizeClass &#123;</span><br><span class="line">        Tiny,</span><br><span class="line">        Small,</span><br><span class="line">        Normal</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 存Tiny大小的Subpage数组长度，默认为32</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> numTinySubpagePools = <span class="number">512</span> &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    <span class="comment">// 池化ByteBuf分配器</span></span><br><span class="line">    <span class="keyword">final</span> PooledByteBufAllocator parent;</span><br><span class="line">    <span class="comment">// chunk的最大树高（层数）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> maxOrder;</span><br><span class="line">    <span class="comment">// chunk的page大小</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> pageSize;</span><br><span class="line">    <span class="comment">// 从1开始左移到页大小的位置，默认13，1&lt;&lt;13 = 8192</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> pageShifts;</span><br><span class="line">    <span class="comment">// chunk的大小</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> chunkSize;</span><br><span class="line">    <span class="comment">// 子页mask，~(pageSize -1)大于pageSize的位为1，pageSize的位为0</span></span><br><span class="line">    <span class="comment">// 需要分配容量 &amp; subpageOverflowMask !=0 则容量要大于PageSize</span></span><br><span class="line">    <span class="comment">// 判断分配请求为Tiny/Small即分配subpage</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> subpageOverflowMask;</span><br><span class="line">    <span class="comment">// 存Small大小的Subpage数组长度，默认为32</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> numSmallSubpagePools;</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> directMemoryCacheAlignment;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> directMemoryCacheAlignmentMask;</span><br><span class="line">    <span class="comment">// tiny和small</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PoolSubpage&lt;T&gt;[] tinySubpagePools;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PoolSubpage&lt;T&gt;[] smallSubpagePools;</span><br><span class="line">    <span class="comment">// qxxx代表了PoolChunkList的使用率</span></span><br><span class="line">    <span class="comment">// 低使用率的在前，chunk使用率低的会不断的从高使用率的List中移动到低使用率的List中</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PoolChunkList&lt;T&gt; q050;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PoolChunkList&lt;T&gt; q025;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PoolChunkList&lt;T&gt; q000;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PoolChunkList&lt;T&gt; qInit; <span class="comment">// 刚初始化的</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PoolChunkList&lt;T&gt; q075;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PoolChunkList&lt;T&gt; q100;</span><br><span class="line">    <span class="comment">// 指标</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;PoolChunkListMetric&gt; chunkListMetrics;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Metrics for allocations and deallocations</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> allocationsNormal;</span><br><span class="line">    <span class="comment">// 原子性计数器，对jdk类的封装，&gt;=1.8底层使用LongAddr，&lt;1.8使用AtomicLong</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LongCounter allocationsTiny = PlatformDependent.newLongCounter();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LongCounter allocationsSmall = PlatformDependent.newLongCounter();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LongCounter allocationsHuge = PlatformDependent.newLongCounter();</span><br><span class="line">    <span class="comment">// 激活的Huge级别内存量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LongCounter activeBytesHuge = PlatformDependent.newLongCounter();</span><br><span class="line">    <span class="comment">// 剩余存储单元</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> deallocationsTiny;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> deallocationsSmall;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> deallocationsNormal;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We need to use the LongCounter here as this is not guarded via synchronized block.</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LongCounter deallocationsHuge = PlatformDependent.newLongCounter();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Number of thread caches backed by this arena.</span></span><br><span class="line">    <span class="keyword">final</span> AtomicInteger numThreadCaches = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><p>构造器中主要是成员变量的初始化。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">PoolArena</span><span class="params">(PooledByteBufAllocator parent, <span class="keyword">int</span> pageSize,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> maxOrder, <span class="keyword">int</span> pageShifts, <span class="keyword">int</span> chunkSize, <span class="keyword">int</span> cacheAlignment)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.parent = parent;</span><br><span class="line">    <span class="keyword">this</span>.pageSize = pageSize;</span><br><span class="line">    <span class="keyword">this</span>.maxOrder = maxOrder;</span><br><span class="line">    <span class="keyword">this</span>.pageShifts = pageShifts;</span><br><span class="line">    <span class="keyword">this</span>.chunkSize = chunkSize;</span><br><span class="line">    directMemoryCacheAlignment = cacheAlignment;</span><br><span class="line">    directMemoryCacheAlignmentMask = cacheAlignment - <span class="number">1</span>;</span><br><span class="line">    subpageOverflowMask = ~(pageSize - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 创建数组</span></span><br><span class="line">    tinySubpagePools = newSubpagePoolArray(numTinySubpagePools);</span><br><span class="line">    <span class="comment">// 构建头结点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tinySubpagePools.length; i ++) &#123;</span><br><span class="line">        tinySubpagePools[i] = newSubpagePoolHead(pageSize);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    numSmallSubpagePools = pageShifts - <span class="number">9</span>;</span><br><span class="line">    smallSubpagePools = newSubpagePoolArray(numSmallSubpagePools);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; smallSubpagePools.length; i ++) &#123;</span><br><span class="line">        smallSubpagePools[i] = newSubpagePoolHead(pageSize);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 各个使用率的ChunkList</span></span><br><span class="line">    q100 = <span class="keyword">new</span> PoolChunkList&lt;T&gt;(<span class="keyword">this</span>, <span class="keyword">null</span>, <span class="number">100</span>, Integer.MAX_VALUE, chunkSize);</span><br><span class="line">    q075 = <span class="keyword">new</span> PoolChunkList&lt;T&gt;(<span class="keyword">this</span>, q100, <span class="number">75</span>, <span class="number">100</span>, chunkSize);</span><br><span class="line">    q050 = <span class="keyword">new</span> PoolChunkList&lt;T&gt;(<span class="keyword">this</span>, q075, <span class="number">50</span>, <span class="number">100</span>, chunkSize);</span><br><span class="line">    q025 = <span class="keyword">new</span> PoolChunkList&lt;T&gt;(<span class="keyword">this</span>, q050, <span class="number">25</span>, <span class="number">75</span>, chunkSize);</span><br><span class="line">    q000 = <span class="keyword">new</span> PoolChunkList&lt;T&gt;(<span class="keyword">this</span>, q025, <span class="number">1</span>, <span class="number">50</span>, chunkSize);</span><br><span class="line">    qInit = <span class="keyword">new</span> PoolChunkList&lt;T&gt;(<span class="keyword">this</span>, q000, Integer.MIN_VALUE, <span class="number">25</span>, chunkSize);</span><br><span class="line"></span><br><span class="line">    q100.prevList(q075);</span><br><span class="line">    q075.prevList(q050);</span><br><span class="line">    q050.prevList(q025);</span><br><span class="line">    q025.prevList(q000);</span><br><span class="line">    q000.prevList(<span class="keyword">null</span>);</span><br><span class="line">    qInit.prevList(qInit);</span><br><span class="line">    <span class="comment">// 指标</span></span><br><span class="line">    List&lt;PoolChunkListMetric&gt; metrics = <span class="keyword">new</span> ArrayList&lt;PoolChunkListMetric&gt;(<span class="number">6</span>);</span><br><span class="line">    metrics.add(qInit);</span><br><span class="line">    metrics.add(q000);</span><br><span class="line">    metrics.add(q025);</span><br><span class="line">    metrics.add(q050);</span><br><span class="line">    metrics.add(q075);</span><br><span class="line">    metrics.add(q100);</span><br><span class="line">    chunkListMetrics = Collections.unmodifiableList(metrics);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> PoolSubpage&lt;T&gt; <span class="title">newSubpagePoolHead</span><span class="params">(<span class="keyword">int</span> pageSize)</span> </span>&#123;</span><br><span class="line">    PoolSubpage&lt;T&gt; head = <span class="keyword">new</span> PoolSubpage&lt;T&gt;(pageSize);</span><br><span class="line">    head.prev = head;</span><br><span class="line">    head.next = head;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="keyword">private</span> PoolSubpage&lt;T&gt;[] newSubpagePoolArray(<span class="keyword">int</span> size) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PoolSubpage[size];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>双向链表：高利用率的chunk会前后移动，低利用率的chunk会向前移动。</p>
<p>null&lt;-q000&lt;-q025&lt;-q050&lt;-q075&lt;-q100</p>
<p>qInit-&gt;q000-&gt;q025-&gt;q050-&gt;q075-&gt;q100</p>
<p>qInit用于存储第一次初始化的chunk。</p>
<h3 id="内存分配allocate"><a href="#内存分配allocate" class="headerlink" title="内存分配allocate"></a>内存分配allocate</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">PooledByteBuf&lt;T&gt; <span class="title">allocate</span><span class="params">(PoolThreadCache cache, <span class="keyword">int</span> reqCapacity, <span class="keyword">int</span> maxCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// newByteBuf抽象方法</span></span><br><span class="line">    PooledByteBuf&lt;T&gt; buf = newByteBuf(maxCapacity);</span><br><span class="line">    allocate(cache, buf, reqCapacity);</span><br><span class="line">    <span class="keyword">return</span> buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际是调用allocate(PoolThreadCache cache, PooledByteBuf<t> buf, final int reqCapacity)方法分配内存。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">allocate</span><span class="params">(PoolThreadCache cache, PooledByteBuf&lt;T&gt; buf, <span class="keyword">final</span> <span class="keyword">int</span> reqCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将容量进行处理</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> normCapacity = normalizeCapacity(reqCapacity);</span><br><span class="line">    <span class="comment">// 容量小于pageSize</span></span><br><span class="line">    <span class="keyword">if</span> (isTinyOrSmall(normCapacity)) &#123; <span class="comment">// capacity &lt; pageSize</span></span><br><span class="line">        <span class="keyword">int</span> tableIdx;</span><br><span class="line">        PoolSubpage&lt;T&gt;[] table;</span><br><span class="line">        <span class="comment">// tiny</span></span><br><span class="line">        <span class="keyword">boolean</span> tiny = isTiny(normCapacity);</span><br><span class="line">        <span class="keyword">if</span> (tiny) &#123; <span class="comment">// &lt; 512</span></span><br><span class="line">            <span class="comment">// 从ThreadCache中分配</span></span><br><span class="line">            <span class="keyword">if</span> (cache.allocateTiny(<span class="keyword">this</span>, buf, reqCapacity, normCapacity)) &#123;</span><br><span class="line">                <span class="comment">// was able to allocate out of the cache so move on</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 定位tinySubpagePools数组中的位置</span></span><br><span class="line">            tableIdx = tinyIdx(normCapacity);</span><br><span class="line">            table = tinySubpagePools;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 从ThreadCache中分配</span></span><br><span class="line">            <span class="keyword">if</span> (cache.allocateSmall(<span class="keyword">this</span>, buf, reqCapacity, normCapacity)) &#123;</span><br><span class="line">                <span class="comment">// was able to allocate out of the cache so move on</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 定位smallSubpagePools数组中的位置</span></span><br><span class="line">            tableIdx = smallIdx(normCapacity);</span><br><span class="line">            table = smallSubpagePools;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> PoolSubpage&lt;T&gt; head = table[tableIdx];</span><br><span class="line">        <span class="comment">// 头结点加锁</span></span><br><span class="line">        <span class="keyword">synchronized</span> (head) &#123;</span><br><span class="line">            <span class="keyword">final</span> PoolSubpage&lt;T&gt; s = head.next;</span><br><span class="line">            <span class="keyword">if</span> (s != head) &#123;</span><br><span class="line">                <span class="keyword">assert</span> s.doNotDestroy &amp;&amp; s.elemSize == normCapacity;</span><br><span class="line">                <span class="comment">// 使用Subpage的分配方法</span></span><br><span class="line">                <span class="keyword">long</span> handle = s.allocate();</span><br><span class="line">                <span class="keyword">assert</span> handle &gt;= <span class="number">0</span>;</span><br><span class="line">                <span class="comment">// 初始化</span></span><br><span class="line">                s.chunk.initBufWithSubpage(buf, <span class="keyword">null</span>, handle, reqCapacity);</span><br><span class="line">                <span class="comment">// count加一</span></span><br><span class="line">                incTinySmallAllocation(tiny);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// tiny 和 small都没有分配成功则执行allocateNormal进行分配</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            allocateNormal(buf, reqCapacity, normCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// count加一</span></span><br><span class="line">        incTinySmallAllocation(tiny);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (normCapacity &lt;= chunkSize) &#123;</span><br><span class="line">        <span class="comment">// 从ThreadCache中分配</span></span><br><span class="line">        <span class="keyword">if</span> (cache.allocateNormal(<span class="keyword">this</span>, buf, reqCapacity, normCapacity)) &#123;</span><br><span class="line">            <span class="comment">// was able to allocate out of the cache so move on</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">// 分配</span></span><br><span class="line">            allocateNormal(buf, reqCapacity, normCapacity);</span><br><span class="line">            ++allocationsNormal;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// huge级别的内存分配</span></span><br><span class="line">        <span class="comment">// Huge allocations are never served via the cache so just call allocateHuge</span></span><br><span class="line">        allocateHuge(buf, reqCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></t></p>
<ol>
<li>将容量reqCapacity进行处理得到normCapacity；</li>
<li>如果小于pageSize(也就是为tiny/small):<ol>
<li>如果是tiny:先从ThreaCache中分配，如果失败则计算tiny数组中的位置tableIdx，并将table设置为tinySubpagePools；</li>
<li>如果是small:先从ThreaCache中分配，如果失败则计算small数组中的位置tableIdx，并将table设置为smallSubpagePools；</li>
<li>取出tableIdx所在的元素head;</li>
<li>加锁：<ol>
<li>取出s=head.next</li>
<li>如果是s!=head:<ol>
<li>调用s(Subpage)的allocate()进行分配；</li>
<li>s.chunk执行initBufWithSubpage初始化；</li>
<li>tiny使用计数器加一；</li>
<li>return；</li>
</ol>
</li>
</ol>
</li>
<li>加锁执行Normal的内存分配allocateNormal();</li>
</ol>
</li>
<li>如果normCapacity小于chunkSize<ol>
<li>先从ThreaCache中分配，成功则return;</li>
<li>加锁：</li>
<li>allocateNormal()方法分配内存；</li>
<li>allocationsNormal使用计数器加一；</li>
</ol>
</li>
<li>执行allocateHuge()方法分配内存。</li>
</ol>
<h4 id="tiny级别内存分配"><a href="#tiny级别内存分配" class="headerlink" title="tiny级别内存分配"></a>tiny级别内存分配</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">tinyIdx</span><span class="params">(<span class="keyword">int</span> normCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> normCapacity &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="small级别内存分配"><a href="#small级别内存分配" class="headerlink" title="small级别内存分配"></a>small级别内存分配</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">smallIdx</span><span class="params">(<span class="keyword">int</span> normCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tableIdx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = normCapacity &gt;&gt;&gt; <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">while</span> (i != <span class="number">0</span>) &#123;</span><br><span class="line">        i &gt;&gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        tableIdx ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tableIdx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">incTinySmallAllocation</span><span class="params">(<span class="keyword">boolean</span> tiny)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tiny) &#123;</span><br><span class="line">        allocationsTiny.increment();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        allocationsSmall.increment();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="normal级别内存分配"><a href="#normal级别内存分配" class="headerlink" title="normal级别内存分配"></a>normal级别内存分配</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">allocateNormal</span><span class="params">(PooledByteBuf&lt;T&gt; buf, <span class="keyword">int</span> reqCapacity, <span class="keyword">int</span> normCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (q050.allocate(buf, reqCapacity, normCapacity) || q025.allocate(buf, reqCapacity, normCapacity) ||</span><br><span class="line">        q000.allocate(buf, reqCapacity, normCapacity) || qInit.allocate(buf, reqCapacity, normCapacity) ||</span><br><span class="line">        q075.allocate(buf, reqCapacity, normCapacity)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add a new chunk.</span></span><br><span class="line">    PoolChunk&lt;T&gt; c = newChunk(pageSize, maxOrder, pageShifts, chunkSize);</span><br><span class="line">    <span class="keyword">boolean</span> success = c.allocate(buf, reqCapacity, normCapacity);</span><br><span class="line">    <span class="keyword">assert</span> success;</span><br><span class="line">    qInit.add(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>不同使用率的PoolChunkList上进行分配，分配成功则返回；</li>
<li>创建一个新的Chunk，并分配对应的内存；</li>
<li>将新创建的Chunk添加到qInit中。</li>
</ol>
<h4 id="huge级别内存分配"><a href="#huge级别内存分配" class="headerlink" title="huge级别内存分配"></a>huge级别内存分配</h4><p>huge级别内存的分配是通过构建一个未受池化的PoolChunk，并调用PooledByteBuf的initUnpooled方法初始化。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">allocateHuge</span><span class="params">(PooledByteBuf&lt;T&gt; buf, <span class="keyword">int</span> reqCapacity)</span> </span>&#123;</span><br><span class="line">    PoolChunk&lt;T&gt; chunk = newUnpooledChunk(reqCapacity);</span><br><span class="line">    activeBytesHuge.add(chunk.chunkSize());</span><br><span class="line">    buf.initUnpooled(chunk, reqCapacity);</span><br><span class="line">    allocationsHuge.increment();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="内存释放free"><a href="#内存释放free" class="headerlink" title="内存释放free"></a>内存释放free</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">(PoolChunk&lt;T&gt; chunk, ByteBuffer nioBuffer, <span class="keyword">long</span> handle, <span class="keyword">int</span> normCapacity, PoolThreadCache cache)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 非池化内存处理</span></span><br><span class="line">    <span class="keyword">if</span> (chunk.unpooled) &#123;</span><br><span class="line">        <span class="keyword">int</span> size = chunk.chunkSize();</span><br><span class="line">        <span class="comment">// 销毁</span></span><br><span class="line">        destroyChunk(chunk);</span><br><span class="line">        <span class="comment">// huge块使用量减去释放的量</span></span><br><span class="line">        activeBytesHuge.add(-size);</span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        deallocationsHuge.increment();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 内存大小类型 Tiny Small Normal</span></span><br><span class="line">        SizeClass sizeClass = sizeClass(normCapacity);</span><br><span class="line">        <span class="comment">// 有cache就加入到cache中</span></span><br><span class="line">        <span class="keyword">if</span> (cache != <span class="keyword">null</span> &amp;&amp; cache.add(<span class="keyword">this</span>, chunk, nioBuffer, handle, normCapacity, sizeClass)) &#123;</span><br><span class="line">            <span class="comment">// cached so not free it.</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 释放Chunk</span></span><br><span class="line">        freeChunk(chunk, handle, sizeClass, nioBuffer, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="destroyChunk"><a href="#destroyChunk" class="headerlink" title="destroyChunk"></a>destroyChunk</h4><p>destroyChunk由子类实现。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">destroyChunk</span><span class="params">(PoolChunk&lt;T&gt; chunk)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p><strong>HeapArena</strong> </p>
<p>堆内内存释放由GC去回收。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">destroyChunk</span><span class="params">(PoolChunk&lt;<span class="keyword">byte</span>[]&gt; chunk)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Rely on GC.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>DirectArena</strong></p>
<p>堆外内存由专门的清理类清理。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">destroyChunk</span><span class="params">(PoolChunk&lt;ByteBuffer&gt; chunk)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (PlatformDependent.useDirectBufferNoCleaner()) &#123;</span><br><span class="line">        PlatformDependent.freeDirectNoCleaner(chunk.memory);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        PlatformDependent.freeDirectBuffer(chunk.memory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="freeChunk"><a href="#freeChunk" class="headerlink" title="freeChunk"></a>freeChunk</h4><p>释放Chunk中的内存空间。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">freeChunk</span><span class="params">(PoolChunk&lt;T&gt; chunk, <span class="keyword">long</span> handle, SizeClass sizeClass, ByteBuffer nioBuffer, <span class="keyword">boolean</span> finalizer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> destroyChunk;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">// We only call this if freeChunk is not called because of the PoolThreadCache finalizer as otherwise this</span></span><br><span class="line">        <span class="comment">// may fail due lazy class-loading in for example tomcat.</span></span><br><span class="line">        <span class="keyword">if</span> (!finalizer) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (sizeClass) &#123;</span><br><span class="line">                <span class="keyword">case</span> Normal:</span><br><span class="line">                    ++deallocationsNormal;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> Small:</span><br><span class="line">                    ++deallocationsSmall;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> Tiny:</span><br><span class="line">                    ++deallocationsTiny;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Error();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// PoolChunkList的free方法，会根据当前chunk的使用率迁移chunk的位置</span></span><br><span class="line">        destroyChunk = !chunk.parent.free(chunk, handle, nioBuffer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果上面的没有清理成功，则直接销毁这个Chunk</span></span><br><span class="line">    <span class="keyword">if</span> (destroyChunk) &#123;</span><br><span class="line">        <span class="comment">// destroyChunk not need to be called while holding the synchronized lock.</span></span><br><span class="line">        destroyChunk(chunk);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="内存扩容reallocate"><a href="#内存扩容reallocate" class="headerlink" title="内存扩容reallocate"></a>内存扩容reallocate</h3><p>分配一个新的内存空间，并将旧数据进行复制。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reallocate</span><span class="params">(PooledByteBuf&lt;T&gt; buf, <span class="keyword">int</span> newCapacity, <span class="keyword">boolean</span> freeOldMemory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> newCapacity &gt;= <span class="number">0</span> &amp;&amp; newCapacity &lt;= buf.maxCapacity();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = buf.length;</span><br><span class="line">    <span class="keyword">if</span> (oldCapacity == newCapacity) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PoolChunk&lt;T&gt; oldChunk = buf.chunk;</span><br><span class="line">    ByteBuffer oldNioBuffer = buf.tmpNioBuf;</span><br><span class="line">    <span class="keyword">long</span> oldHandle = buf.handle;</span><br><span class="line">    T oldMemory = buf.memory;</span><br><span class="line">    <span class="keyword">int</span> oldOffset = buf.offset;</span><br><span class="line">    <span class="keyword">int</span> oldMaxLength = buf.maxLength;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This does not touch buf's reader/writer indices</span></span><br><span class="line">    <span class="comment">// 分配一个新内存</span></span><br><span class="line">    allocate(parent.threadCache(), buf, newCapacity);</span><br><span class="line">    <span class="keyword">int</span> bytesToCopy;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity &gt; oldCapacity) &#123;</span><br><span class="line">        bytesToCopy = oldCapacity;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        buf.trimIndicesToCapacity(newCapacity);</span><br><span class="line">        bytesToCopy = newCapacity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 内存复制</span></span><br><span class="line">    memoryCopy(oldMemory, oldOffset, buf.memory, buf.offset, bytesToCopy);</span><br><span class="line">    <span class="keyword">if</span> (freeOldMemory) &#123;</span><br><span class="line">        free(oldChunk, oldNioBuffer, oldHandle, oldMaxLength, buf.cache);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="查找Subpage头节点findSubpagePoolHead"><a href="#查找Subpage头节点findSubpagePoolHead" class="headerlink" title="查找Subpage头节点findSubpagePoolHead"></a>查找Subpage头节点findSubpagePoolHead</h3><p>findSubpagePoolHead在chunk中使用，当第一次分配分配Subpage内存时（tiny/small）需要通过chunk进行分配，chunk中构建Subpage通过该方法查找头结点，然后将大小一样的Subpage串成链表。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">PoolSubpage&lt;T&gt; <span class="title">findSubpagePoolHead</span><span class="params">(<span class="keyword">int</span> elemSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tableIdx;</span><br><span class="line">    PoolSubpage&lt;T&gt;[] table;</span><br><span class="line">    <span class="keyword">if</span> (isTiny(elemSize)) &#123; <span class="comment">// &lt; 512</span></span><br><span class="line">        <span class="comment">// 除以16</span></span><br><span class="line">        tableIdx = elemSize &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">        table = tinySubpagePools;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        tableIdx = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 除以1024</span></span><br><span class="line">        elemSize &gt;&gt;&gt;= <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">while</span> (elemSize != <span class="number">0</span>) &#123;</span><br><span class="line">            elemSize &gt;&gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            tableIdx ++;</span><br><span class="line">        &#125;</span><br><span class="line">        table = smallSubpagePools;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> table[tableIdx];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="jvm外内存实现DirectArena"><a href="#jvm外内存实现DirectArena" class="headerlink" title="jvm外内存实现DirectArena"></a>jvm外内存实现DirectArena</h2><p>DirectArena是分配堆外内存的实现。</p>
<h3 id="newChunk"><a href="#newChunk" class="headerlink" title="newChunk"></a>newChunk</h3><p>构建新的Chunk<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> PoolChunk&lt;ByteBuffer&gt; <span class="title">newChunk</span><span class="params">(<span class="keyword">int</span> pageSize, <span class="keyword">int</span> maxOrder,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> pageShifts, <span class="keyword">int</span> chunkSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (directMemoryCacheAlignment == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PoolChunk&lt;ByteBuffer&gt;(<span class="keyword">this</span>,</span><br><span class="line">                allocateDirect(chunkSize), pageSize, maxOrder,</span><br><span class="line">                pageShifts, chunkSize, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> ByteBuffer memory = allocateDirect(chunkSize</span><br><span class="line">            + directMemoryCacheAlignment);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PoolChunk&lt;ByteBuffer&gt;(<span class="keyword">this</span>, memory, pageSize,</span><br><span class="line">            maxOrder, pageShifts, chunkSize,</span><br><span class="line">            offsetCacheLine(memory));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="newUnpooledChunk"><a href="#newUnpooledChunk" class="headerlink" title="newUnpooledChunk"></a>newUnpooledChunk</h3><p>构建非池化的Chunk<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> PoolChunk&lt;ByteBuffer&gt; <span class="title">newUnpooledChunk</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (directMemoryCacheAlignment == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PoolChunk&lt;ByteBuffer&gt;(<span class="keyword">this</span>,</span><br><span class="line">                allocateDirect(capacity), capacity, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> ByteBuffer memory = allocateDirect(capacity</span><br><span class="line">            + directMemoryCacheAlignment);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PoolChunk&lt;ByteBuffer&gt;(<span class="keyword">this</span>, memory, capacity,</span><br><span class="line">            offsetCacheLine(memory));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="allocateDirect"><a href="#allocateDirect" class="headerlink" title="allocateDirect"></a>allocateDirect</h3><p>构建堆外内存对象ByteBuffer<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ByteBuffer <span class="title">allocateDirect</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> PlatformDependent.useDirectBufferNoCleaner() ?</span><br><span class="line">            PlatformDependent.allocateDirectNoCleaner(capacity) : ByteBuffer.allocateDirect(capacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="newByteBuf"><a href="#newByteBuf" class="headerlink" title="newByteBuf"></a>newByteBuf</h3><p>ByteBuf是Netty的类，用于对内存（堆内存，jvm外部内存）的统一抽象和管理，这里构建的PooledByteBuf<bytebuffer>只是一个jvm对象，它的memory属性指向实际的内存空间，目前为空，只有通过Arena的allocate方法分配实际的内存空间后才会有值。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> PooledByteBuf&lt;ByteBuffer&gt; <span class="title">newByteBuf</span><span class="params">(<span class="keyword">int</span> maxCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (HAS_UNSAFE) &#123;</span><br><span class="line">        <span class="keyword">return</span> PooledUnsafeDirectByteBuf.newInstance(maxCapacity);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> PooledDirectByteBuf.newInstance(maxCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></bytebuffer></p>
<h3 id="memoryCopy"><a href="#memoryCopy" class="headerlink" title="memoryCopy"></a>memoryCopy</h3><p>内存空间复制<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">memoryCopy</span><span class="params">(ByteBuffer src, <span class="keyword">int</span> srcOffset, ByteBuffer dst, <span class="keyword">int</span> dstOffset, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (HAS_UNSAFE) &#123;</span><br><span class="line">        PlatformDependent.copyMemory(</span><br><span class="line">                PlatformDependent.directBufferAddress(src) + srcOffset,</span><br><span class="line">                PlatformDependent.directBufferAddress(dst) + dstOffset, length);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// We must duplicate the NIO buffers because they may be accessed by other Netty buffers.</span></span><br><span class="line">        src = src.duplicate();</span><br><span class="line">        dst = dst.duplicate();</span><br><span class="line">        src.position(srcOffset).limit(srcOffset + length);</span><br><span class="line">        dst.position(dstOffset);</span><br><span class="line">        dst.put(src);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="堆内存实现HeapArena"><a href="#堆内存实现HeapArena" class="headerlink" title="堆内存实现HeapArena"></a>堆内存实现HeapArena</h2><p>HeapArena实现非常简单，因为内存空间是堆内存，所以直接使用byte数组就可以存储。</p>
<h3 id="newByteArray"><a href="#newByteArray" class="headerlink" title="newByteArray"></a>newByteArray</h3><p>1024以内的内存直接new byte[size]，unsafe中有操作数组的方法，比较大的数组就用unsafe类去操作<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] newByteArray(<span class="keyword">int</span> size) &#123;</span><br><span class="line">    <span class="keyword">return</span> PlatformDependent.allocateUninitializedArray(size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="newChunk-1"><a href="#newChunk-1" class="headerlink" title="newChunk"></a>newChunk</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> PoolChunk&lt;<span class="keyword">byte</span>[]&gt; newChunk(<span class="keyword">int</span> pageSize, <span class="keyword">int</span> maxOrder, <span class="keyword">int</span> pageShifts, <span class="keyword">int</span> chunkSize) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PoolChunk&lt;<span class="keyword">byte</span>[]&gt;(<span class="keyword">this</span>, newByteArray(chunkSize), pageSize, maxOrder, pageShifts, chunkSize, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="newUnpooledChunk-1"><a href="#newUnpooledChunk-1" class="headerlink" title="newUnpooledChunk"></a>newUnpooledChunk</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> PoolChunk&lt;<span class="keyword">byte</span>[]&gt; newUnpooledChunk(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PoolChunk&lt;<span class="keyword">byte</span>[]&gt;(<span class="keyword">this</span>, newByteArray(capacity), capacity, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="newByteBuf-1"><a href="#newByteBuf-1" class="headerlink" title="newByteBuf"></a>newByteBuf</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> PooledByteBuf&lt;<span class="keyword">byte</span>[]&gt; newByteBuf(<span class="keyword">int</span> maxCapacity) &#123;</span><br><span class="line">    <span class="keyword">return</span> HAS_UNSAFE ? PooledUnsafeHeapByteBuf.newUnsafeInstance(maxCapacity)</span><br><span class="line">            : PooledHeapByteBuf.newInstance(maxCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="memoryCopy-1"><a href="#memoryCopy-1" class="headerlink" title="memoryCopy"></a>memoryCopy</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">memoryCopy</span><span class="params">(<span class="keyword">byte</span>[] src, <span class="keyword">int</span> srcOffset, <span class="keyword">byte</span>[] dst, <span class="keyword">int</span> dstOffset, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.arraycopy(src, srcOffset, dst, dstOffset, length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><div class="tags"><a href="/tags/网络/">网络</a><a href="/tags/Netty/">Netty</a><a href="/tags/内存/">内存</a></div><div class="post-nav"><a class="pre" href="/2020/03/18/Netty之旅28PooledByteBuf/">Netty解析二十六：Netty内存分配PooledByteBuf</a><a class="next" href="/2020/03/13/Netty之旅26PoolChunkList/">Netty解析二十四：Netty内存分配PoolChunkList</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="https://SvizzerChow.github.io"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Netty/">Netty</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Sentinel/">Sentinel</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/redis/">redis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/sharding-jdbc/">sharding-jdbc</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/分布式/">分布式</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/并发/">并发</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据库/">数据库</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法/">算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/线程池/">线程池</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/网络/">网络</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/虚拟机/">虚拟机</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/TCP/" style="font-size: 15px;">TCP</a> <a href="/tags/BASE理论/" style="font-size: 15px;">BASE理论</a> <a href="/tags/JavaAgent/" style="font-size: 15px;">JavaAgent</a> <a href="/tags/CAP理论/" style="font-size: 15px;">CAP理论</a> <a href="/tags/集合/" style="font-size: 15px;">集合</a> <a href="/tags/可见性/" style="font-size: 15px;">可见性</a> <a href="/tags/内存模型/" style="font-size: 15px;">内存模型</a> <a href="/tags/MESI/" style="font-size: 15px;">MESI</a> <a href="/tags/volatile/" style="font-size: 15px;">volatile</a> <a href="/tags/MySQL/" style="font-size: 15px;">MySQL</a> <a href="/tags/网络/" style="font-size: 15px;">网络</a> <a href="/tags/Netty/" style="font-size: 15px;">Netty</a> <a href="/tags/channel/" style="font-size: 15px;">channel</a> <a href="/tags/ServerBootstrap/" style="font-size: 15px;">ServerBootstrap</a> <a href="/tags/NioEventLoop/" style="font-size: 15px;">NioEventLoop</a> <a href="/tags/启动/" style="font-size: 15px;">启动</a> <a href="/tags/读写事件/" style="font-size: 15px;">读写事件</a> <a href="/tags/http/" style="font-size: 15px;">http</a> <a href="/tags/线程模型/" style="font-size: 15px;">线程模型</a> <a href="/tags/沾包/" style="font-size: 15px;">沾包</a> <a href="/tags/拆包/" style="font-size: 15px;">拆包</a> <a href="/tags/内存/" style="font-size: 15px;">内存</a> <a href="/tags/NIO/" style="font-size: 15px;">NIO</a> <a href="/tags/限流/" style="font-size: 15px;">限流</a> <a href="/tags/降级/" style="font-size: 15px;">降级</a> <a href="/tags/熔断/" style="font-size: 15px;">熔断</a> <a href="/tags/Sentinel/" style="font-size: 15px;">Sentinel</a> <a href="/tags/源码解析/" style="font-size: 15px;">源码解析</a> <a href="/tags/虚拟机/" style="font-size: 15px;">虚拟机</a> <a href="/tags/原子性/" style="font-size: 15px;">原子性</a> <a href="/tags/long/" style="font-size: 15px;">long</a> <a href="/tags/double/" style="font-size: 15px;">double</a> <a href="/tags/并发/" style="font-size: 15px;">并发</a> <a href="/tags/redis/" style="font-size: 15px;">redis</a> <a href="/tags/NoSQL/" style="font-size: 15px;">NoSQL</a> <a href="/tags/sentinel/" style="font-size: 15px;">sentinel</a> <a href="/tags/zookeeper/" style="font-size: 15px;">zookeeper</a> <a href="/tags/分布式锁/" style="font-size: 15px;">分布式锁</a> <a href="/tags/数据库/" style="font-size: 15px;">数据库</a> <a href="/tags/分库分表/" style="font-size: 15px;">分库分表</a> <a href="/tags/io/" style="font-size: 15px;">io</a> <a href="/tags/同步/" style="font-size: 15px;">同步</a> <a href="/tags/异步/" style="font-size: 15px;">异步</a> <a href="/tags/线程池/" style="font-size: 15px;">线程池</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/Excutors/" style="font-size: 15px;">Excutors</a> <a href="/tags/多线程/" style="font-size: 15px;">多线程</a> <a href="/tags/AbstractExecutorService/" style="font-size: 15px;">AbstractExecutorService</a> <a href="/tags/ThreadPoolExecutor/" style="font-size: 15px;">ThreadPoolExecutor</a> <a href="/tags/ScheduledThreadPoolExecutor/" style="font-size: 15px;">ScheduledThreadPoolExecutor</a> <a href="/tags/缓存/" style="font-size: 15px;">缓存</a> <a href="/tags/缓存行/" style="font-size: 15px;">缓存行</a> <a href="/tags/FutureTask/" style="font-size: 15px;">FutureTask</a> <a href="/tags/轮询/" style="font-size: 15px;">轮询</a> <a href="/tags/算法/" style="font-size: 15px;">算法</a> <a href="/tags/Spring/" style="font-size: 15px;">Spring</a> <a href="/tags/sharding-jdbc/" style="font-size: 15px;">sharding-jdbc</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/03/18/Netty之旅30对象池Recycler/">Netty解析二十七：Netty对象池Recycler</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/18/Netty之旅29PooledByteBufAllocator/">Netty解析二十七：Netty内存分配PooledByteBufAllocator</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/18/Netty之旅28PooledByteBuf/">Netty解析二十六：Netty内存分配PooledByteBuf</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/16/Netty之旅27PoolArena/">Netty解析二十五：Netty内存分配PoolArena</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/13/Netty之旅26PoolChunkList/">Netty解析二十四：Netty内存分配PoolChunkList</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/12/Netty之旅25PoolSubpage/">Netty解析二十三：Netty内存分配PoolSubpage</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/06/Netty之旅24PoolChunk/">Netty解析二十二：Netty内存分配PoolChunk</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/05/Netty之旅23内存分配模型/">Netty解析二十一：Netty内存分配模型</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/03/同步异步和阻塞非阻塞/">同步/异步与阻塞/非阻塞</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/02/Netty之旅22Netty沾包拆包/">Netty解析二十：Netty中的拆包沾包处理</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2017-2020 <a href="/." rel="nofollow">SvizzerChow's Blog.</a><a rel="nofollow" target="_blank" href="http://www.beian.miit.gov.cn"> 浙ICP备18053179号</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>