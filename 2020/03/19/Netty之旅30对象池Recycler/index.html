<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="我的个人博客"><title>Netty解析二十八：Netty对象池Recycler | SvizzerChow's Blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Netty解析二十八：Netty对象池Recycler</h1><a id="logo" href="/.">SvizzerChow's Blog</a><p class="description">Leaning</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Netty解析二十八：Netty对象池Recycler</h1><div class="post-meta">Mar 19, 2020<span> | </span><span class="category"><a href="/categories/Netty/">Netty</a></span></div><div class="post-content"><meta name="referrer" content="no-referrer">


<p>Netty对象缓存处处可见，通过继承Recycler类即可实现对象缓存。</p>
<a id="more"></a>
<h2 id="Recycler的使用方式"><a href="#Recycler的使用方式" class="headerlink" title="Recycler的使用方式"></a>Recycler的使用方式</h2><p>定义一个拥有Recycler.Handle属性的类，并有方法执行对象回收：<code>handle.recycle(this)</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalUnsafeDirectByteBuf</span> <span class="keyword">extends</span> <span class="title">UnpooledUnsafeDirectByteBuf</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Handle&lt;ThreadLocalUnsafeDirectByteBuf&gt; handle;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ThreadLocalUnsafeDirectByteBuf</span><span class="params">(Handle&lt;ThreadLocalUnsafeDirectByteBuf&gt; handle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(UnpooledByteBufAllocator.DEFAULT, <span class="number">256</span>, Integer.MAX_VALUE);</span><br><span class="line">        <span class="keyword">this</span>.handle = handle;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (capacity() &gt; THREAD_LOCAL_BUFFER_SIZE) &#123;</span><br><span class="line">            <span class="keyword">super</span>.deallocate();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            clear();</span><br><span class="line">            handle.recycle(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>实现一个Recycler对象，会要求实现newObject方法，这个是缓存池中没有对象时调用该方法创建对象。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Recycler&lt;ThreadLocalUnsafeDirectByteBuf&gt; RECYCLER =</span><br><span class="line">                <span class="keyword">new</span> Recycler&lt;ThreadLocalUnsafeDirectByteBuf&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">protected</span> ThreadLocalUnsafeDirectByteBuf <span class="title">newObject</span><span class="params">(Handle&lt;ThreadLocalUnsafeDirectByteBuf&gt; handle)</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">new</span> ThreadLocalUnsafeDirectByteBuf(handle);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br></pre></td></tr></table></figure></p>
<p>获取对象：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocalUnsafeDirectByteBuf buf = RECYCLER.get();</span><br></pre></td></tr></table></figure></p>
<p>当对象使用完毕时，手动执行对象释放<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buf.deallocate()</span><br></pre></td></tr></table></figure></p>
<p>注意deallocate()方法内部必须调用handle.recycle(this)。</p>
<h2 id="Recycler原理解析"><a href="#Recycler原理解析" class="headerlink" title="Recycler原理解析"></a>Recycler原理解析</h2><h3 id="继承关系以及成员变量"><a href="#继承关系以及成员变量" class="headerlink" title="继承关系以及成员变量"></a>继承关系以及成员变量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Recycler</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> InternalLogger logger = InternalLoggerFactory.getInstance(Recycler.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"rawtypes"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Handle NOOP_HANDLE = <span class="keyword">new</span> Handle() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recycle</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// NOOP</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicInteger ID_GENERATOR = <span class="keyword">new</span> AtomicInteger(Integer.MIN_VALUE);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OWN_THREAD_ID = ID_GENERATOR.getAndIncrement();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_MAX_CAPACITY_PER_THREAD = <span class="number">4</span> * <span class="number">1024</span>; <span class="comment">// Use 4k instances as default.</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_MAX_CAPACITY_PER_THREAD;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INITIAL_CAPACITY;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_SHARED_CAPACITY_FACTOR;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_DELAYED_QUEUES_PER_THREAD;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LINK_CAPACITY;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RATIO;</span><br><span class="line">    <span class="comment">// 每条线程最大容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> maxCapacityPerThread;</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> maxSharedCapacityFactor;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> ratioMask;</span><br><span class="line">    <span class="comment">// 每个线程最大的延迟队列数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> maxDelayedQueuesPerThread;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// FastThreadLocal存储栈，栈中存储对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> FastThreadLocal&lt;Stack&lt;T&gt;&gt; threadLocal = <span class="keyword">new</span> FastThreadLocal&lt;Stack&lt;T&gt;&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Stack&lt;T&gt; <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Stack&lt;T&gt;(Recycler.<span class="keyword">this</span>, Thread.currentThread(), maxCapacityPerThread, maxSharedCapacityFactor,</span><br><span class="line">                    ratioMask, maxDelayedQueuesPerThread);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onRemoval</span><span class="params">(Stack&lt;T&gt; value)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// Let us remove the WeakOrderQueue from the WeakHashMap directly if its safe to remove some overhead</span></span><br><span class="line">            <span class="keyword">if</span> (value.threadRef.get() == Thread.currentThread()) &#123;</span><br><span class="line">               <span class="keyword">if</span> (DELAYED_RECYCLED.isSet()) &#123;</span><br><span class="line">                   DELAYED_RECYCLED.get().remove(value);</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> FastThreadLocal&lt;Map&lt;Stack&lt;?&gt;, WeakOrderQueue&gt;&gt; DELAYED_RECYCLED =</span><br><span class="line">            <span class="keyword">new</span> FastThreadLocal&lt;Map&lt;Stack&lt;?&gt;, WeakOrderQueue&gt;&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> Map&lt;Stack&lt;?&gt;, WeakOrderQueue&gt; initialValue() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> WeakHashMap&lt;Stack&lt;?&gt;, WeakOrderQueue&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>静态代码块中初始化默认值<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="comment">// In the future, we might have different maxCapacity for different object types.</span></span><br><span class="line">    <span class="comment">// e.g. io.netty.recycler.maxCapacity.writeTask</span></span><br><span class="line">    <span class="comment">//      io.netty.recycler.maxCapacity.outboundBuffer</span></span><br><span class="line">    <span class="keyword">int</span> maxCapacityPerThread = SystemPropertyUtil.getInt(<span class="string">"io.netty.recycler.maxCapacityPerThread"</span>,</span><br><span class="line">            SystemPropertyUtil.getInt(<span class="string">"io.netty.recycler.maxCapacity"</span>, DEFAULT_INITIAL_MAX_CAPACITY_PER_THREAD));</span><br><span class="line">    <span class="keyword">if</span> (maxCapacityPerThread &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        maxCapacityPerThread = DEFAULT_INITIAL_MAX_CAPACITY_PER_THREAD;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DEFAULT_MAX_CAPACITY_PER_THREAD = maxCapacityPerThread;</span><br><span class="line"></span><br><span class="line">    MAX_SHARED_CAPACITY_FACTOR = max(<span class="number">2</span>,</span><br><span class="line">            SystemPropertyUtil.getInt(<span class="string">"io.netty.recycler.maxSharedCapacityFactor"</span>,</span><br><span class="line">                    <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">    MAX_DELAYED_QUEUES_PER_THREAD = max(<span class="number">0</span>,</span><br><span class="line">            SystemPropertyUtil.getInt(<span class="string">"io.netty.recycler.maxDelayedQueuesPerThread"</span>,</span><br><span class="line">                    <span class="comment">// We use the same value as default EventLoop number</span></span><br><span class="line">                    NettyRuntime.availableProcessors() * <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">    LINK_CAPACITY = safeFindNextPositivePowerOfTwo(</span><br><span class="line">            max(SystemPropertyUtil.getInt(<span class="string">"io.netty.recycler.linkCapacity"</span>, <span class="number">16</span>), <span class="number">16</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// By default we allow one push to a Recycler for each 8th try on handles that were never recycled before.</span></span><br><span class="line">    <span class="comment">// This should help to slowly increase the capacity of the recycler while not be too sensitive to allocation</span></span><br><span class="line">    <span class="comment">// bursts.</span></span><br><span class="line">    RATIO = safeFindNextPositivePowerOfTwo(SystemPropertyUtil.getInt(<span class="string">"io.netty.recycler.ratio"</span>, <span class="number">8</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEFAULT_MAX_CAPACITY_PER_THREAD == <span class="number">0</span>) &#123;</span><br><span class="line">            logger.debug(<span class="string">"-Dio.netty.recycler.maxCapacityPerThread: disabled"</span>);</span><br><span class="line">            logger.debug(<span class="string">"-Dio.netty.recycler.maxSharedCapacityFactor: disabled"</span>);</span><br><span class="line">            logger.debug(<span class="string">"-Dio.netty.recycler.linkCapacity: disabled"</span>);</span><br><span class="line">            logger.debug(<span class="string">"-Dio.netty.recycler.ratio: disabled"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            logger.debug(<span class="string">"-Dio.netty.recycler.maxCapacityPerThread: &#123;&#125;"</span>, DEFAULT_MAX_CAPACITY_PER_THREAD);</span><br><span class="line">            logger.debug(<span class="string">"-Dio.netty.recycler.maxSharedCapacityFactor: &#123;&#125;"</span>, MAX_SHARED_CAPACITY_FACTOR);</span><br><span class="line">            logger.debug(<span class="string">"-Dio.netty.recycler.linkCapacity: &#123;&#125;"</span>, LINK_CAPACITY);</span><br><span class="line">            logger.debug(<span class="string">"-Dio.netty.recycler.ratio: &#123;&#125;"</span>, RATIO);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    INITIAL_CAPACITY = min(DEFAULT_MAX_CAPACITY_PER_THREAD, <span class="number">256</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">Recycler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(DEFAULT_MAX_CAPACITY_PER_THREAD);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">Recycler</span><span class="params">(<span class="keyword">int</span> maxCapacityPerThread)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(maxCapacityPerThread, MAX_SHARED_CAPACITY_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">Recycler</span><span class="params">(<span class="keyword">int</span> maxCapacityPerThread, <span class="keyword">int</span> maxSharedCapacityFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(maxCapacityPerThread, maxSharedCapacityFactor, RATIO, MAX_DELAYED_QUEUES_PER_THREAD);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">Recycler</span><span class="params">(<span class="keyword">int</span> maxCapacityPerThread, <span class="keyword">int</span> maxSharedCapacityFactor,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">int</span> ratio, <span class="keyword">int</span> maxDelayedQueuesPerThread)</span> </span>&#123;</span><br><span class="line">    ratioMask = safeFindNextPositivePowerOfTwo(ratio) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (maxCapacityPerThread &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.maxCapacityPerThread = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.maxSharedCapacityFactor = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">this</span>.maxDelayedQueuesPerThread = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.maxCapacityPerThread = maxCapacityPerThread;</span><br><span class="line">        <span class="keyword">this</span>.maxSharedCapacityFactor = max(<span class="number">1</span>, maxSharedCapacityFactor);</span><br><span class="line">        <span class="keyword">this</span>.maxDelayedQueuesPerThread = max(<span class="number">0</span>, maxDelayedQueuesPerThread);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="获取对象get"><a href="#获取对象get" class="headerlink" title="获取对象get"></a>获取对象get</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (maxCapacityPerThread == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> newObject((Handle&lt;T&gt;) NOOP_HANDLE);</span><br><span class="line">    &#125;</span><br><span class="line">    Stack&lt;T&gt; stack = threadLocal.get();</span><br><span class="line">    DefaultHandle&lt;T&gt; handle = stack.pop();</span><br><span class="line">    <span class="keyword">if</span> (handle == <span class="keyword">null</span>) &#123;</span><br><span class="line">        handle = stack.newHandle();</span><br><span class="line">        handle.value = newObject(handle);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (T) handle.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>如果最大线程缓存数为0，即不允许缓存了，则执行newObject()构建信息对象；</li>
<li>通过threadLocal获取当前线程的栈缓存；</li>
<li>从栈中弹出栈顶元素DefaultHandle；</li>
<li>如果DefaultHandle为null：<ol>
<li>通过栈创建新的DefaultHandle；</li>
<li>为新的DefaultHandle创建对象newObject();</li>
</ol>
</li>
<li>返回handle.value。</li>
</ol>
<h3 id="返还对象recycle"><a href="#返还对象recycle" class="headerlink" title="返还对象recycle"></a>返还对象recycle</h3><p>Handle#recycle(Object)替代了该方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">recycle</span><span class="params">(T o, Handle&lt;T&gt; handle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (handle == NOOP_HANDLE) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DefaultHandle&lt;T&gt; h = (DefaultHandle&lt;T&gt;) handle;</span><br><span class="line">    <span class="keyword">if</span> (h.stack.parent != <span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    h.recycle(o);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>如果handle是NOOP_HANDLE则返回false;</li>
<li>如果handler的stack所属的Recycle不是当前对象则返回false；</li>
<li>执行handler的recycle方法。</li>
</ol>
<h2 id="Recycler-DefaultHandle"><a href="#Recycler-DefaultHandle" class="headerlink" title="Recycler.DefaultHandle"></a>Recycler.DefaultHandle</h2><p>DefaultHandle是Handle的默认实现。</p>
<p>Handle接口的核心是提供recycle方法的回调，在recycle方法中可以做资源回收。</p>
<ul>
<li>当element出栈pop的时候会将recycleId和lastRecycledId设置为0；</li>
<li>当element存入栈的时候会将recycleId和lastRecycledId设置为OWN_THREAD_ID；</li>
<li>当element存入延迟队列的时候会将lastRecycledId设置为队列的id；</li>
<li>当element从延迟队列迁移到栈中时会将recycleId设置为lastRecycledId；</li>
</ul>
<p>通过这两个状态可以判断是否被回收。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultHandle</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Handle</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> lastRecycledId;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> recycleId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> hasBeenRecycled;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Stack&lt;?&gt; stack;</span><br><span class="line">    <span class="keyword">private</span> Object value;</span><br><span class="line"></span><br><span class="line">    DefaultHandle(Stack&lt;?&gt; stack) &#123;</span><br><span class="line">        <span class="keyword">this</span>.stack = stack;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recycle</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (object != value) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"object does not belong to handle"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Stack&lt;?&gt; stack = <span class="keyword">this</span>.stack;</span><br><span class="line">        <span class="keyword">if</span> (lastRecycledId != recycleId || stack == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"recycled already"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stack.push(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DefaultHandle的核心就在于它的recycle方法，在recycle方法中会将this进行回收，将this入栈。</p>
<p><strong>recycle方法：</strong></p>
<ol>
<li>校验回收的对象是否一致；</li>
<li>校验循环id；</li>
<li>将当前对象push进栈；</li>
</ol>
<h2 id="Recycler-Stack"><a href="#Recycler-Stack" class="headerlink" title="Recycler.Stack"></a>Recycler.Stack</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/168294/1584695867592-assets/web-upload/602bce85-1864-4404-bc71-eb26f738e0bf.png" alt></p>
<p>这个栈有个特殊的结构：</p>
<ul>
<li>如果对象获取的线程和回收的线程一致，则会执行push()-&gt;pushNow()将对象存入栈；</li>
<li>如果对象获取的线程和回收的线程不一致，则会在当前线程创建一个延迟队列，执行push()-&gt;pushLater()将对象存入延迟队列；且栈会持有该队列（链表存队列）；</li>
<li>当获取对象时，先从栈中取对象；如果栈长为0，则会执行scavenge()-&gt;WeakOrderQueue.transfer()将持有的队列中的对象迁移到栈中，然后返回对象。</li>
</ul>
<p>WeakOrderQueue实现了延迟队列，使得对象可以跨线程共享。</p>
<h3 id="继承关系以及成员变量-1"><a href="#继承关系以及成员变量-1" class="headerlink" title="继承关系以及成员变量"></a>继承关系以及成员变量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Stack</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 所属的Recycler</span></span><br><span class="line">    <span class="keyword">final</span> Recycler&lt;T&gt; parent;</span><br><span class="line">    <span class="comment">// 当前线程的弱引用</span></span><br><span class="line">    <span class="keyword">final</span> WeakReference&lt;Thread&gt; threadRef;</span><br><span class="line">    <span class="comment">// 可用技术</span></span><br><span class="line">    <span class="keyword">final</span> AtomicInteger availableSharedCapacity;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> maxDelayedQueues;</span><br><span class="line">    <span class="comment">// 最大容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> maxCapacity;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> ratioMask;</span><br><span class="line">    <span class="comment">// 存储数组</span></span><br><span class="line">    <span class="keyword">private</span> DefaultHandle&lt;?&gt;[] elements;</span><br><span class="line">    <span class="comment">// 当前大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> handleRecycleCount = -<span class="number">1</span>; <span class="comment">// Start with -1 so the first one will be recycled.</span></span><br><span class="line">    <span class="keyword">private</span> WeakOrderQueue cursor, prev;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> WeakOrderQueue head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="构造器-1"><a href="#构造器-1" class="headerlink" title="构造器"></a>构造器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> Stack(Recycler&lt;T&gt; parent, Thread thread, <span class="keyword">int</span> maxCapacity, <span class="keyword">int</span> maxSharedCapacityFactor,</span><br><span class="line">        <span class="keyword">int</span> ratioMask, <span class="keyword">int</span> maxDelayedQueues) &#123;</span><br><span class="line">    <span class="keyword">this</span>.parent = parent;</span><br><span class="line">    <span class="comment">// 弱引用</span></span><br><span class="line">    threadRef = <span class="keyword">new</span> WeakReference&lt;Thread&gt;(thread);</span><br><span class="line">    <span class="keyword">this</span>.maxCapacity = maxCapacity;</span><br><span class="line">    <span class="comment">// 计数器</span></span><br><span class="line">    availableSharedCapacity = <span class="keyword">new</span> AtomicInteger(max(maxCapacity / maxSharedCapacityFactor, LINK_CAPACITY));</span><br><span class="line">    elements = <span class="keyword">new</span> DefaultHandle[min(INITIAL_CAPACITY, maxCapacity)];</span><br><span class="line">    <span class="keyword">this</span>.ratioMask = ratioMask;</span><br><span class="line">    <span class="keyword">this</span>.maxDelayedQueues = maxDelayedQueues;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="newHandle"><a href="#newHandle" class="headerlink" title="newHandle"></a>newHandle</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DefaultHandle&lt;T&gt; <span class="title">newHandle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DefaultHandle&lt;T&gt;(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="入栈push"><a href="#入栈push" class="headerlink" title="入栈push"></a>入栈push</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(DefaultHandle&lt;?&gt; item)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 校验线程是否一致</span></span><br><span class="line">    Thread currentThread = Thread.currentThread();</span><br><span class="line">    <span class="keyword">if</span> (threadRef.get() == currentThread) &#123;</span><br><span class="line">        <span class="comment">// The current Thread is the thread that belongs to the Stack, we can try to push the object now.</span></span><br><span class="line">        pushNow(item);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// The current Thread is not the one that belongs to the Stack</span></span><br><span class="line">        <span class="comment">// (or the Thread that belonged to the Stack was collected already), we need to signal that the push</span></span><br><span class="line">        <span class="comment">// happens later.</span></span><br><span class="line">        pushLater(item, currentThread);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>如果当前线程与Stack中弱引用存储的线程一样，则立即入栈执行pushNow；</li>
<li>不然延迟入栈，执行pushLater；</li>
</ol>
<p>Stack入栈实现了同步回收（同一个线程获取对象并回收），和异步回收（获取对象和回收对象的线程不一致）。</p>
<ul>
<li>同步回收：直接将对象存入栈中；</li>
<li>异步回收：将对象存储延迟队列中，只有在Stack中没有对象时才会将Stack存储的延迟队列链表中的对象存入栈中。</li>
</ul>
<h4 id="立即入栈pushNow"><a href="#立即入栈pushNow" class="headerlink" title="立即入栈pushNow"></a>立即入栈pushNow</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pushNow</span><span class="params">(DefaultHandle&lt;?&gt; item)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((item.recycleId | item.lastRecycledId) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"recycled already"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    item.recycleId = item.lastRecycledId = OWN_THREAD_ID;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> size = <span class="keyword">this</span>.size;</span><br><span class="line">    <span class="comment">// 存不下了释放</span></span><br><span class="line">    <span class="keyword">if</span> (size &gt;= maxCapacity || dropHandle(item)) &#123;</span><br><span class="line">        <span class="comment">// Hit the maximum capacity or should drop - drop the possibly youngest object.</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 数组两倍扩容</span></span><br><span class="line">    <span class="keyword">if</span> (size == elements.length) &#123;</span><br><span class="line">        elements = Arrays.copyOf(elements, min(size &lt;&lt; <span class="number">1</span>, maxCapacity));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 存起来</span></span><br><span class="line">    elements[size] = item;</span><br><span class="line">    <span class="keyword">this</span>.size = size + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>校验handle的循环id；</li>
<li>如果当前容量已经到上限，则释放并返回；</li>
<li>如果当前长度size和数组长度一样，则对数组进行两倍扩容；</li>
<li>将handle存入数组的末尾，并将size加一；</li>
</ol>
<h4 id="延迟入栈pushLater"><a href="#延迟入栈pushLater" class="headerlink" title="延迟入栈pushLater"></a>延迟入栈pushLater</h4><p>当Stock中线程的弱引用与持有Stock的线程不一致时，就会执行pushLater将handle存储延迟队列中。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pushLater</span><span class="params">(DefaultHandle&lt;?&gt; item, Thread thread)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Map是WeakHashMap，避免强引用</span></span><br><span class="line">    <span class="comment">// 获取延迟队列</span></span><br><span class="line">    Map&lt;Stack&lt;?&gt;, WeakOrderQueue&gt; delayedRecycled = DELAYED_RECYCLED.get();</span><br><span class="line">    WeakOrderQueue queue = delayedRecycled.get(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (queue == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 一个线程最大的延迟队列数</span></span><br><span class="line">        <span class="keyword">if</span> (delayedRecycled.size() &gt;= maxDelayedQueues) &#123;</span><br><span class="line">            <span class="comment">// Add a dummy queue so we know we should drop the object</span></span><br><span class="line">            <span class="comment">// 舍弃这个handle</span></span><br><span class="line">            delayedRecycled.put(<span class="keyword">this</span>, WeakOrderQueue.DUMMY);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Check if we already reached the maximum number of delayed queues and if we can allocate at all.</span></span><br><span class="line">        <span class="comment">// 分配一个队列</span></span><br><span class="line">        <span class="comment">// 并且会将这个队列插入Stack的队列链表的head</span></span><br><span class="line">        <span class="keyword">if</span> ((queue = WeakOrderQueue.allocate(<span class="keyword">this</span>, thread)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// drop object</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 延迟队列加入map</span></span><br><span class="line">        delayedRecycled.put(<span class="keyword">this</span>, queue);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (queue == WeakOrderQueue.DUMMY) &#123;</span><br><span class="line">        <span class="comment">// drop object</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将handle加入延迟队列</span></span><br><span class="line">    queue.add(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>获取延迟队列；</li>
<li>如果队列没有：<ol>
<li>判断是否达到单个线程最大延迟队列数，如果是则舍弃这个handle，将单前栈的延迟队列设置为WeakOrderQueue.DUMMY；</li>
<li>WeakOrderQueue.allocate分配一个队列，如果没有分配成功则return；</li>
<li>将新分配的延迟队列加入到map中；</li>
</ol>
</li>
<li>如果队列是WeakOrderQueue.DUMMY，则return；</li>
<li>将handle加入到队列中。</li>
</ol>
<h3 id="栈顶出栈pop"><a href="#栈顶出栈pop" class="headerlink" title="栈顶出栈pop"></a>栈顶出栈pop</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DefaultHandle&lt;T&gt; <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = <span class="keyword">this</span>.size;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果没有则从延迟队列中采集</span></span><br><span class="line">        <span class="keyword">if</span> (!scavenge()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        size = <span class="keyword">this</span>.size;</span><br><span class="line">        <span class="keyword">if</span> (size &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// double check, avoid races</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从栈尾去除对象</span></span><br><span class="line">    size --;</span><br><span class="line">    DefaultHandle ret = elements[size];</span><br><span class="line">    elements[size] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 校验循环id</span></span><br><span class="line">    <span class="comment">// 并发</span></span><br><span class="line">    <span class="keyword">if</span> (ret.lastRecycledId != ret.recycleId) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"recycled multiple times"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ret.recycleId = <span class="number">0</span>;</span><br><span class="line">    ret.lastRecycledId = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.size = size;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>如果当前栈大小为0，则调用scavenge()到延迟队列中采集；<ol>
<li>如果还是小于0则返回null；</li>
</ol>
</li>
<li>栈大小减一；</li>
<li>将栈尾的数据去除；</li>
<li>校验循环id；</li>
<li>将循环id都设置为0，并返回。</li>
</ol>
<h3 id="收集scavenge"><a href="#收集scavenge" class="headerlink" title="收集scavenge"></a>收集scavenge</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">scavenge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// continue an existing scavenge, if any</span></span><br><span class="line">    <span class="keyword">if</span> (scavengeSome()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// reset our scavenge cursor</span></span><br><span class="line">    prev = <span class="keyword">null</span>;</span><br><span class="line">    cursor = head;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">scavengeSome</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    WeakOrderQueue prev;</span><br><span class="line">    WeakOrderQueue cursor = <span class="keyword">this</span>.cursor;</span><br><span class="line">    <span class="keyword">if</span> (cursor == <span class="keyword">null</span>) &#123;</span><br><span class="line">        prev = <span class="keyword">null</span>;</span><br><span class="line">        cursor = head;</span><br><span class="line">        <span class="keyword">if</span> (cursor == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        prev = <span class="keyword">this</span>.prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> success = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (cursor.transfer(<span class="keyword">this</span>)) &#123;</span><br><span class="line">            success = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        WeakOrderQueue next = cursor.next;</span><br><span class="line">        <span class="comment">// 线程引用没有了，线程被回收了</span></span><br><span class="line">        <span class="keyword">if</span> (cursor.owner.get() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// If the thread associated with the queue is gone, unlink it, after</span></span><br><span class="line">            <span class="comment">// performing a volatile read to confirm there is no data left to collect.</span></span><br><span class="line">            <span class="comment">// We never unlink the first queue, as we don't want to synchronize on updating the head.</span></span><br><span class="line">            <span class="keyword">if</span> (cursor.hasFinalData()) &#123;</span><br><span class="line">                <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (cursor.transfer(<span class="keyword">this</span>)) &#123;</span><br><span class="line">                        success = <span class="keyword">true</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123;</span><br><span class="line">                prev.setNext(next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            prev = cursor;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cursor = next;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">while</span> (cursor != <span class="keyword">null</span> &amp;&amp; !success);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.prev = prev;</span><br><span class="line">    <span class="keyword">this</span>.cursor = cursor;</span><br><span class="line">    <span class="keyword">return</span> success;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>如果cursor没有，则取head；</li>
<li>如果head也没有，则返回false；</li>
<li>循环cursor不为null且!success：<ol>
<li>cursor.transfer将队列中的Handle存到Stack上，设置success为true；</li>
<li>如果cursor.owner.get() == null，线程被回收了：<ol>
<li>如果cursor中还有数据，循环：<ol>
<li>cursor.transfer将队列中的Handle存到Stack上；<ol>
<li>清空成功则设置success为true;</li>
<li>不然则break;</li>
</ol>
</li>
</ol>
</li>
<li>将cursor从链表中去除，前节点连接到后续节点；</li>
</ol>
</li>
<li>前置节点设为cursor；</li>
<li>cursor设置为cursor的next节点；</li>
</ol>
</li>
<li>更新this.prev = prev和this.cursor = cursor；</li>
<li>返回success。</li>
</ol>
<h2 id="Recycler-WeakOrderQueue"><a href="#Recycler-WeakOrderQueue" class="headerlink" title="Recycler.WeakOrderQueue"></a>Recycler.WeakOrderQueue</h2><h3 id="继承关系及成员变量"><a href="#继承关系及成员变量" class="headerlink" title="继承关系及成员变量"></a>继承关系及成员变量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">WeakOrderQueue</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当一个线程的延迟队列数达到上限，就不允许handle再创建了，此时设置为DUMMY</span></span><br><span class="line">    <span class="comment">// DUMMY队列不会添加任何数据</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> WeakOrderQueue DUMMY = <span class="keyword">new</span> WeakOrderQueue();</span><br><span class="line">    <span class="comment">// 队列的头部，Head其实是实际的队列，存储了队列的总容量availableSharedCapacity</span></span><br><span class="line">    <span class="comment">// 队列存储的数据是Head中的Link节点，Link节点构成链表</span></span><br><span class="line">    <span class="comment">// 每个Link节点有长度为16的数组，当Link存储达到上限是会从Head的availableSharedCapacity划去16长度</span></span><br><span class="line">    <span class="comment">// 然后创建新的Link节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Head head;</span><br><span class="line">    <span class="keyword">private</span> Link tail;</span><br><span class="line">    <span class="comment">// pointer to another queue of delayed items for the same stack</span></span><br><span class="line">    <span class="comment">// 队列本身是链表的节点</span></span><br><span class="line">    <span class="keyword">private</span> WeakOrderQueue next;</span><br><span class="line">    <span class="comment">// 持有线程的弱引用</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> WeakReference&lt;Thread&gt; owner;</span><br><span class="line">    <span class="comment">// 唯一id，每个队列的id都不一样</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> id = ID_GENERATOR.getAndIncrement();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="WeakOrderQueue-Link"><a href="#WeakOrderQueue-Link" class="headerlink" title="WeakOrderQueue.Link"></a>WeakOrderQueue.Link</h4><p>Link是队列中真正存储数据的地方，每个Link可以存储LINK_CAPACITY个对象，一个队列中的Link数为Head.availableSharedCapacity/LINK_CAPACITY</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Link</span> <span class="keyword">extends</span> <span class="title">AtomicInteger</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DefaultHandle&lt;?&gt;[] elements = <span class="keyword">new</span> DefaultHandle[LINK_CAPACITY];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> readIndex;</span><br><span class="line">    Link next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="WeakOrderQueue-Head"><a href="#WeakOrderQueue-Head" class="headerlink" title="WeakOrderQueue.Head"></a>WeakOrderQueue.Head</h4><p>Head维护availableSharedCapacity，来控制Link的数量。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Head</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger availableSharedCapacity;</span><br><span class="line"></span><br><span class="line">    Link link;</span><br><span class="line"></span><br><span class="line">    Head(AtomicInteger availableSharedCapacity) &#123;</span><br><span class="line">        <span class="keyword">this</span>.availableSharedCapacity = availableSharedCapacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// <span class="doctag">TODO:</span> In the future when we move to Java9+ we should use java.lang.ref.Cleaner.</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">// ...代码省略了</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将Link释放了，空间加回来</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reclaimSpace</span><span class="params">(<span class="keyword">int</span> space)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> space &gt;= <span class="number">0</span>;</span><br><span class="line">        availableSharedCapacity.addAndGet(space);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 申请空间，用于创建Link，因为一个Link要占用LINK_CAPACITY大小</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">reserveSpace</span><span class="params">(<span class="keyword">int</span> space)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> reserveSpace(availableSharedCapacity, space);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">reserveSpace</span><span class="params">(AtomicInteger availableSharedCapacity, <span class="keyword">int</span> space)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> space &gt;= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> available = availableSharedCapacity.get();</span><br><span class="line">            <span class="keyword">if</span> (available &lt; space) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (availableSharedCapacity.compareAndSet(available, available - space)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="分配队列allocate"><a href="#分配队列allocate" class="headerlink" title="分配队列allocate"></a>分配队列allocate</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> WeakOrderQueue <span class="title">allocate</span><span class="params">(Stack&lt;?&gt; stack, Thread thread)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// We allocated a Link so reserve the space</span></span><br><span class="line">    <span class="keyword">return</span> Head.reserveSpace(stack.availableSharedCapacity, LINK_CAPACITY)</span><br><span class="line">            ? newQueue(stack, thread) : <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="创建新队列newQueue"><a href="#创建新队列newQueue" class="headerlink" title="创建新队列newQueue"></a>创建新队列newQueue</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> WeakOrderQueue <span class="title">newQueue</span><span class="params">(Stack&lt;?&gt; stack, Thread thread)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> WeakOrderQueue queue = <span class="keyword">new</span> WeakOrderQueue(stack, thread);</span><br><span class="line">    <span class="comment">// Done outside of the constructor to ensure WeakOrderQueue.this does not escape the constructor and so</span></span><br><span class="line">    <span class="comment">// may be accessed while its still constructed.</span></span><br><span class="line">    <span class="comment">// 将队列插入的栈的队列链表中</span></span><br><span class="line">    stack.setHead(queue);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> queue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="添加add"><a href="#添加add" class="headerlink" title="添加add"></a>添加add</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(DefaultHandle&lt;?&gt; handle)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将handle的lastRecycledId设置为队列的Id</span></span><br><span class="line">    handle.lastRecycledId = id;</span><br><span class="line">    <span class="comment">// 队尾</span></span><br><span class="line">    Link tail = <span class="keyword">this</span>.tail;</span><br><span class="line">    <span class="keyword">int</span> writeIndex;</span><br><span class="line">    <span class="comment">// LINK_CAPACITY = 16</span></span><br><span class="line">    <span class="keyword">if</span> ((writeIndex = tail.get()) == LINK_CAPACITY) &#123;</span><br><span class="line">        <span class="comment">// 是否到队里存储上限availableSharedCapacity</span></span><br><span class="line">        <span class="comment">// 如果能从availableSharedCapacity中减到LINK_CAPACITY，就可以继续存</span></span><br><span class="line">        <span class="keyword">if</span> (!head.reserveSpace(LINK_CAPACITY)) &#123;</span><br><span class="line">            <span class="comment">// Drop it.</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// We allocate a Link so reserve the space</span></span><br><span class="line">        <span class="comment">// 划分到了LINK_CAPACITY空间就可以创建Link节点了</span></span><br><span class="line">        <span class="keyword">this</span>.tail = tail = tail.next = <span class="keyword">new</span> Link();</span><br><span class="line">        <span class="comment">// 写指针更新为新的节点</span></span><br><span class="line">        writeIndex = tail.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 尾节点存入handle</span></span><br><span class="line">    tail.elements[writeIndex] = handle;</span><br><span class="line">    <span class="comment">// 清空handle所属的Stack</span></span><br><span class="line">    handle.stack = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// we lazy set to ensure that setting stack to null appears before we unnull it in the owning thread;</span></span><br><span class="line">    <span class="comment">// this also means we guarantee visibility of an element in the queue if we see the index updated</span></span><br><span class="line">    <span class="comment">// 更新index，lazySet是原子类的UNSAFE的方法</span></span><br><span class="line">    <span class="comment">// 用于更新，相对于普通的更新，它少了一部分内存屏障（store-load），提升了性能</span></span><br><span class="line">    <span class="comment">// 缺点是其他线程看到数据变更会有延迟</span></span><br><span class="line">    tail.lazySet(writeIndex + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>将handle的lastRecycledId设置为队列的Id</li>
<li>如果writeIndex到了数组尾：<ol>
<li>如果不能从availableSharedCapacity中减到LINK_CAPACITY，则退出；</li>
<li>不然，new Link()，writeIndex指向新Link的起始位置；</li>
</ol>
</li>
<li>将handle存入tail.elements[writeIndex]</li>
<li>清空handle所属的Stack</li>
<li>writeIndex加一</li>
</ol>
<h3 id="将队列数据存到栈中transfer"><a href="#将队列数据存到栈中transfer" class="headerlink" title="将队列数据存到栈中transfer"></a>将队列数据存到栈中transfer</h3><p>从Stock中获取对象时如果没有对象，则调用Stock.scavenge()将延迟队列中的对象迁到栈中。</p>
<p>transfer一次只会将一个Link中的对象迁移到栈中，所以Stock.scavenge()-&gt;scavengeSome()中会循环调用transfer方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">transfer</span><span class="params">(Stack&lt;?&gt; dst)</span> </span>&#123;</span><br><span class="line">        Link head = <span class="keyword">this</span>.head.link;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (head.readIndex == LINK_CAPACITY) &#123;</span><br><span class="line">            <span class="comment">// 读完了</span></span><br><span class="line">            <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 读下一个link</span></span><br><span class="line">            <span class="keyword">this</span>.head.link = head = head.next;</span><br><span class="line">            <span class="comment">// 是否空间</span></span><br><span class="line">            <span class="keyword">this</span>.head.reclaimSpace(LINK_CAPACITY);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> srcStart = head.readIndex;</span><br><span class="line">        <span class="keyword">int</span> srcEnd = head.get();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> srcSize = srcEnd - srcStart;</span><br><span class="line">        <span class="keyword">if</span> (srcSize == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> dstSize = dst.size;</span><br><span class="line">        <span class="comment">// Stack需要的容量</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> expectedCapacity = dstSize + srcSize;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (expectedCapacity &gt; dst.elements.length) &#123;</span><br><span class="line">            <span class="comment">// 栈进行扩容</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> actualCapacity = dst.increaseCapacity(expectedCapacity);</span><br><span class="line">            srcEnd = min(srcStart + actualCapacity - dstSize, srcEnd);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (srcStart != srcEnd) &#123;</span><br><span class="line">            <span class="keyword">final</span> DefaultHandle[] srcElems = head.elements;</span><br><span class="line">            <span class="keyword">final</span> DefaultHandle[] dstElems = dst.elements;</span><br><span class="line">            <span class="keyword">int</span> newDstSize = dstSize;</span><br><span class="line">            <span class="comment">// 将link中的数组拷贝到栈的数组上</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = srcStart; i &lt; srcEnd; i++) &#123;</span><br><span class="line">                DefaultHandle element = srcElems[i];</span><br><span class="line">                <span class="comment">// 更新recycleId</span></span><br><span class="line">                <span class="comment">// 当element出栈pop的时候会将recycleId和lastRecycledId设置为0</span></span><br><span class="line">                <span class="comment">// 当element存入栈的时候会将recycleId和lastRecycledId设置为OWN_THREAD_ID</span></span><br><span class="line">                <span class="comment">// 当element存入延迟队列的时候会将lastRecycledId设置为队列的id</span></span><br><span class="line">                <span class="keyword">if</span> (element.recycleId == <span class="number">0</span>) &#123;</span><br><span class="line">                    element.recycleId = element.lastRecycledId;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.recycleId != element.lastRecycledId) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"recycled already"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 清空link的栈</span></span><br><span class="line">                srcElems[i] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// 循环使用超过一定次数就会放弃回收该对象</span></span><br><span class="line">                <span class="keyword">if</span> (dst.dropHandle(element)) &#123;</span><br><span class="line">                    <span class="comment">// Drop the object.</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                element.stack = dst;</span><br><span class="line">                <span class="comment">// 存到栈</span></span><br><span class="line">                dstElems[newDstSize ++] = element;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果整个link都被清除了，而且有后续节点，就释放空间</span></span><br><span class="line">            <span class="keyword">if</span> (srcEnd == LINK_CAPACITY &amp;&amp; head.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// Add capacity back as the Link is GCed.</span></span><br><span class="line">                <span class="keyword">this</span>.head.reclaimSpace(LINK_CAPACITY);</span><br><span class="line">                <span class="keyword">this</span>.head.link = head.next;</span><br><span class="line">            &#125;</span><br><span class="line">            head.readIndex = srcEnd;</span><br><span class="line">            <span class="comment">// 没有从队列中将对象存到栈中</span></span><br><span class="line">            <span class="keyword">if</span> (dst.size == newDstSize) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 更新新的长度</span></span><br><span class="line">            dst.size = newDstSize;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// The destination stack is full already.</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>如果全部读完了，则返回false；</li>
<li>不然就读下一个Link；</li>
<li>计算这个Link要读多少个元素；</li>
<li>栈扩容；</li>
<li>循环拷贝Link数组中的元素到栈中，并清空Link数组；</li>
<li>拷贝时校验recycleId和lastRecycledId；</li>
<li>并将element.recycleId = element.lastRecycledId，此时lastRecycledId为队列id；</li>
<li>释放link空间；</li>
<li>如果没有从队列中迁移对象到栈中，则返回false；</li>
<li>不然，更新栈长度，且放回true；</li>
</ol>
</div><div class="tags"><a href="/tags/网络/">网络</a><a href="/tags/Netty/">Netty</a><a href="/tags/内存/">内存</a></div><div class="post-nav"><a class="pre" href="/2020/04/09/kafka生产者客户端发送逻辑简析/">kafka：生产者客户端发送逻辑简析</a><a class="next" href="/2020/03/18/Netty之旅29PooledByteBufAllocator/">Netty解析二十七：Netty内存分配PooledByteBufAllocator</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="https://SvizzerChow.github.io"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Netty/">Netty</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Sentinel/">Sentinel</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/kafka/">kafka</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/redis/">redis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/sharding-jdbc/">sharding-jdbc</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/分布式/">分布式</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/并发/">并发</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据库/">数据库</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法/">算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/线程池/">线程池</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/网络/">网络</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/虚拟机/">虚拟机</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/kafka/" style="font-size: 15px;">kafka</a> <a href="/tags/BASE理论/" style="font-size: 15px;">BASE理论</a> <a href="/tags/虚拟机/" style="font-size: 15px;">虚拟机</a> <a href="/tags/JavaAgent/" style="font-size: 15px;">JavaAgent</a> <a href="/tags/集合/" style="font-size: 15px;">集合</a> <a href="/tags/可见性/" style="font-size: 15px;">可见性</a> <a href="/tags/内存模型/" style="font-size: 15px;">内存模型</a> <a href="/tags/MESI/" style="font-size: 15px;">MESI</a> <a href="/tags/volatile/" style="font-size: 15px;">volatile</a> <a href="/tags/MySQL/" style="font-size: 15px;">MySQL</a> <a href="/tags/网络/" style="font-size: 15px;">网络</a> <a href="/tags/Netty/" style="font-size: 15px;">Netty</a> <a href="/tags/channel/" style="font-size: 15px;">channel</a> <a href="/tags/ServerBootstrap/" style="font-size: 15px;">ServerBootstrap</a> <a href="/tags/NioEventLoop/" style="font-size: 15px;">NioEventLoop</a> <a href="/tags/启动/" style="font-size: 15px;">启动</a> <a href="/tags/线程模型/" style="font-size: 15px;">线程模型</a> <a href="/tags/读写事件/" style="font-size: 15px;">读写事件</a> <a href="/tags/http/" style="font-size: 15px;">http</a> <a href="/tags/沾包/" style="font-size: 15px;">沾包</a> <a href="/tags/拆包/" style="font-size: 15px;">拆包</a> <a href="/tags/内存/" style="font-size: 15px;">内存</a> <a href="/tags/NIO/" style="font-size: 15px;">NIO</a> <a href="/tags/限流/" style="font-size: 15px;">限流</a> <a href="/tags/降级/" style="font-size: 15px;">降级</a> <a href="/tags/熔断/" style="font-size: 15px;">熔断</a> <a href="/tags/Sentinel/" style="font-size: 15px;">Sentinel</a> <a href="/tags/源码解析/" style="font-size: 15px;">源码解析</a> <a href="/tags/redis/" style="font-size: 15px;">redis</a> <a href="/tags/NoSQL/" style="font-size: 15px;">NoSQL</a> <a href="/tags/TCP/" style="font-size: 15px;">TCP</a> <a href="/tags/CAP理论/" style="font-size: 15px;">CAP理论</a> <a href="/tags/事务/" style="font-size: 15px;">事务</a> <a href="/tags/消费者/" style="font-size: 15px;">消费者</a> <a href="/tags/rebalance/" style="font-size: 15px;">rebalance</a> <a href="/tags/coordinator/" style="font-size: 15px;">coordinator</a> <a href="/tags/原子性/" style="font-size: 15px;">原子性</a> <a href="/tags/long/" style="font-size: 15px;">long</a> <a href="/tags/double/" style="font-size: 15px;">double</a> <a href="/tags/并发/" style="font-size: 15px;">并发</a> <a href="/tags/生产者/" style="font-size: 15px;">生产者</a> <a href="/tags/sentinel/" style="font-size: 15px;">sentinel</a> <a href="/tags/zookeeper/" style="font-size: 15px;">zookeeper</a> <a href="/tags/分布式锁/" style="font-size: 15px;">分布式锁</a> <a href="/tags/数据库/" style="font-size: 15px;">数据库</a> <a href="/tags/分库分表/" style="font-size: 15px;">分库分表</a> <a href="/tags/io/" style="font-size: 15px;">io</a> <a href="/tags/同步/" style="font-size: 15px;">同步</a> <a href="/tags/异步/" style="font-size: 15px;">异步</a> <a href="/tags/线程池/" style="font-size: 15px;">线程池</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/Excutors/" style="font-size: 15px;">Excutors</a> <a href="/tags/多线程/" style="font-size: 15px;">多线程</a> <a href="/tags/AbstractExecutorService/" style="font-size: 15px;">AbstractExecutorService</a> <a href="/tags/ThreadPoolExecutor/" style="font-size: 15px;">ThreadPoolExecutor</a> <a href="/tags/ScheduledThreadPoolExecutor/" style="font-size: 15px;">ScheduledThreadPoolExecutor</a> <a href="/tags/FutureTask/" style="font-size: 15px;">FutureTask</a> <a href="/tags/缓存/" style="font-size: 15px;">缓存</a> <a href="/tags/缓存行/" style="font-size: 15px;">缓存行</a> <a href="/tags/轮询/" style="font-size: 15px;">轮询</a> <a href="/tags/算法/" style="font-size: 15px;">算法</a> <a href="/tags/Spring/" style="font-size: 15px;">Spring</a> <a href="/tags/sharding-jdbc/" style="font-size: 15px;">sharding-jdbc</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/05/07/kafka事务/">kafka：事务原理</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/15/kafka消费者rebalance简析/">kafka：消费者rebalance简析</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/09/kafka生产者客户端发送逻辑简析/">kafka：生产者客户端发送逻辑简析</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/19/Netty之旅30对象池Recycler/">Netty解析二十八：Netty对象池Recycler</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/18/Netty之旅29PooledByteBufAllocator/">Netty解析二十七：Netty内存分配PooledByteBufAllocator</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/18/Netty之旅28PooledByteBuf/">Netty解析二十六：Netty内存分配PooledByteBuf</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/16/Netty之旅27PoolArena/">Netty解析二十五：Netty内存分配PoolArena</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/13/Netty之旅26PoolChunkList/">Netty解析二十四：Netty内存分配PoolChunkList</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/12/Netty之旅25PoolSubpage/">Netty解析二十三：Netty内存分配PoolSubpage</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/06/Netty之旅24PoolChunk/">Netty解析二十二：Netty内存分配PoolChunk</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2017-2020 <a href="/." rel="nofollow">SvizzerChow's Blog.</a><a rel="nofollow" target="_blank" href="http://www.beian.miit.gov.cn"> 浙ICP备18053179号</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>