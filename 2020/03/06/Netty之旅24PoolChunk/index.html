<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="我的个人博客"><title>Netty解析二十二：Netty内存分配PoolChunk | SvizzerChow's Blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Netty解析二十二：Netty内存分配PoolChunk</h1><a id="logo" href="/.">SvizzerChow's Blog</a><p class="description">Leaning</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Netty解析二十二：Netty内存分配PoolChunk</h1><div class="post-meta">Mar 6, 2020<span> | </span><span class="category"><a href="/categories/Netty/">Netty</a></span></div><div class="post-content"><meta name="referrer" content="no-referrer">


<p>Netty的内存分配与JEMalloc类似，从大到小可以划分为：Arena, Chunk, Page, SubPage</p>
<p>其中核心的是Chunk，Chunk使用伙伴分配算法分配Chunk中的Page节点，而Page由更小的SubPage组成。</p>
<a id="more"></a>
<h2 id="PoolChunk的伙伴分配算法"><a href="#PoolChunk的伙伴分配算法" class="headerlink" title="PoolChunk的伙伴分配算法"></a>PoolChunk的伙伴分配算法</h2><p>PoolChunk中有两个用数组实现的二叉树【memoryMap，depthMap】，初始时memoryMap，depthMap中存储的都是当前节点的高度，memoryMap用于存储分配信息，depthMap只是存储高度初始化后就不再改变。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/168294/1583914356520-assets/web-upload/d1313f88-0f75-4bc0-ba7d-c12ed50ecbc9.png" alt></p>
<p>左图表示每个节点的编号，节点从1开始，0被舍弃。这样节点的父子关系更容易计算:子节点加倍，父节点减半，比如512的子节点为1024=512 * 2。右图表示每个节点的高度，从0开始。在代表二叉树的数组中，左图中节点上的数字作为数组索引即id，右图节点上的数字作为值。初始状态时，memoryMap和depthMap相等。</p>
<p>当某个节点被使用时会将memoryMap中的节点高度值改为最大高度加一（maxOrder+1）而depthMap在修改后不变。如下图（节点序号|高度）：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/168294/1583898453566-assets/web-upload/2bc1927e-1a38-480f-bb49-0108fb540b1f.png" alt></p>
<ol>
<li>查找到4号节点；</li>
<li>将4号节点的高度设置成已使用（maxOrder+1）；</li>
<li>依次将父节点的高度设置为其子节点的最小值。</li>
</ol>
<p>这个改变的高度就是memoryMap数组中存储的值。</p>
<h2 id="PoolChunk解析"><a href="#PoolChunk解析" class="headerlink" title="PoolChunk解析"></a>PoolChunk解析</h2><h3 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PoolChunk</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">PoolChunkMetric</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>PoolChunkMetric接口指定了3个指标方法：usage(), chunkSize(), freeBytes();</p>
<h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Arena对象</span></span><br><span class="line"><span class="keyword">final</span> PoolArena&lt;T&gt; arena; </span><br><span class="line"><span class="comment">// 实际的内存存储对象，例如ByteBuf            </span></span><br><span class="line"><span class="keyword">final</span> T memory;     </span><br><span class="line"><span class="comment">// 是否池化        </span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> unpooled;</span><br><span class="line"><span class="comment">// 偏移量</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> offset;</span><br><span class="line"><span class="comment">// 二叉树存储，memoryMap分配信息，depthMap各节点初始树高</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] memoryMap;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] depthMap;</span><br><span class="line"><span class="comment">// 子页</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> PoolSubpage&lt;T&gt;[] subpages;</span><br><span class="line"><span class="comment">// 子页mask，~(pageSize -1)大于pageSize的位为1，pageSize的位为0</span></span><br><span class="line"><span class="comment">// 需要分配容量 &amp; subpageOverflowMask !=0 则容量要大于PageSize</span></span><br><span class="line"><span class="comment">// 判断分配请求为Tiny/Small即分配subpage</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> subpageOverflowMask;</span><br><span class="line"><span class="comment">// 一个Page的大小, 默认8KB=8192</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> pageSize;</span><br><span class="line"><span class="comment">// 从1开始左移到页大小的位置，默认13，1&lt;&lt;13 = 8192</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> pageShifts;</span><br><span class="line"><span class="comment">// 最大树高，默认11</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> maxOrder;</span><br><span class="line"><span class="comment">// chunk块大小，默认16MB</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> chunkSize;</span><br><span class="line"><span class="comment">// log2(16MB) = 24</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> log2ChunkSize;</span><br><span class="line"><span class="comment">// 可分配subpage的最大节点数即11层节点数，默认2048</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> maxSubpageAllocs;</span><br><span class="line"><span class="comment">// 节点易分配（不可用）的标记值，maxOrder + 1</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">byte</span> unusable;</span><br><span class="line"><span class="comment">// nioBuffer缓存双向队列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;ByteBuffer&gt; cachedNioBuffers;</span><br><span class="line"><span class="comment">// 剩余空间</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> freeBytes;</span><br><span class="line"><span class="comment">// PoolChunkList 用于Arena管理Chunk</span></span><br><span class="line">PoolChunkList&lt;T&gt; parent;</span><br><span class="line">PoolChunk&lt;T&gt; prev;</span><br><span class="line">PoolChunk&lt;T&gt; next;</span><br></pre></td></tr></table></figure>
<h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><p>有两个构造器，一个普通（池化）构造器，一个非池化构造器。在构造器中有一些值的初始化是非常需要关注的。</p>
<p><strong>普通（池化）构造器</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">PoolChunk(PoolArena&lt;T&gt; arena, T memory, <span class="keyword">int</span> pageSize, <span class="keyword">int</span> maxOrder, <span class="keyword">int</span> pageShifts, <span class="keyword">int</span> chunkSize, <span class="keyword">int</span> offset) &#123;</span><br><span class="line">    unpooled = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">this</span>.arena = arena;</span><br><span class="line">    <span class="keyword">this</span>.memory = memory;</span><br><span class="line">    <span class="keyword">this</span>.pageSize = pageSize;</span><br><span class="line">    <span class="keyword">this</span>.pageShifts = pageShifts;</span><br><span class="line">    <span class="keyword">this</span>.maxOrder = maxOrder;</span><br><span class="line">    <span class="keyword">this</span>.chunkSize = chunkSize;</span><br><span class="line">    <span class="keyword">this</span>.offset = offset;</span><br><span class="line">    unusable = (<span class="keyword">byte</span>) (maxOrder + <span class="number">1</span>); <span class="comment">// 标记不可用的值</span></span><br><span class="line">    log2ChunkSize = log2(chunkSize); <span class="comment">// chunk大小的幂</span></span><br><span class="line">    subpageOverflowMask = ~(pageSize - <span class="number">1</span>);</span><br><span class="line">    freeBytes = chunkSize;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">assert</span> maxOrder &lt; <span class="number">30</span> : <span class="string">"maxOrder should be &lt; 30, but is: "</span> + maxOrder;</span><br><span class="line">    maxSubpageAllocs = <span class="number">1</span> &lt;&lt; maxOrder;</span><br><span class="line"></span><br><span class="line">    memoryMap = <span class="keyword">new</span> <span class="keyword">byte</span>[maxSubpageAllocs &lt;&lt; <span class="number">1</span>];</span><br><span class="line">    depthMap = <span class="keyword">new</span> <span class="keyword">byte</span>[memoryMap.length];</span><br><span class="line">    <span class="keyword">int</span> memoryMapIndex = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 初始化两个二叉树，值都是节点高度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">0</span>; d &lt;= maxOrder; ++ d) &#123; <span class="comment">// move down the tree one level at a time</span></span><br><span class="line">        <span class="keyword">int</span> depth = <span class="number">1</span> &lt;&lt; d;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">0</span>; p &lt; depth; ++ p) &#123;</span><br><span class="line">            memoryMap[memoryMapIndex] = (<span class="keyword">byte</span>) d;</span><br><span class="line">            depthMap[memoryMapIndex] = (<span class="keyword">byte</span>) d;</span><br><span class="line">            memoryMapIndex ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// new PoolSubpage[size]</span></span><br><span class="line">    subpages = newSubpageArray(maxSubpageAllocs);</span><br><span class="line">    cachedNioBuffers = <span class="keyword">new</span> ArrayDeque&lt;ByteBuffer&gt;(<span class="number">8</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>非池化构造器</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">PoolChunk(PoolArena&lt;T&gt; arena, T memory, <span class="keyword">int</span> size, <span class="keyword">int</span> offset) &#123;</span><br><span class="line">    unpooled = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">this</span>.arena = arena;</span><br><span class="line">    <span class="keyword">this</span>.memory = memory;</span><br><span class="line">    <span class="keyword">this</span>.offset = offset;</span><br><span class="line">    memoryMap = <span class="keyword">null</span>;</span><br><span class="line">    depthMap = <span class="keyword">null</span>;</span><br><span class="line">    subpages = <span class="keyword">null</span>;</span><br><span class="line">    subpageOverflowMask = <span class="number">0</span>;</span><br><span class="line">    pageSize = <span class="number">0</span>;</span><br><span class="line">    pageShifts = <span class="number">0</span>;</span><br><span class="line">    maxOrder = <span class="number">0</span>;</span><br><span class="line">    unusable = (<span class="keyword">byte</span>) (maxOrder + <span class="number">1</span>);</span><br><span class="line">    chunkSize = size;</span><br><span class="line">    log2ChunkSize = log2(chunkSize);</span><br><span class="line">    maxSubpageAllocs = <span class="number">0</span>;</span><br><span class="line">    cachedNioBuffers = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="分配内存"><a href="#分配内存" class="headerlink" title="分配内存"></a>分配内存</h3><p>分配内存的入口在allocate方法。</p>
<p>reqCapacity是实际需要的空间，normCapacity是PoolArena#normalizeCapacity方法计算的空间。例如reqCapacity要123b空间，不可能给123b空间，必然是大于这个数。因为chunk的空间大小划分是均分的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">allocate</span><span class="params">(PooledByteBuf&lt;T&gt; buf, <span class="keyword">int</span> reqCapacity, <span class="keyword">int</span> normCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> handle;</span><br><span class="line">    <span class="comment">// 如果需要分配的空间大于等于pageSize则执行allocateRun，不然执行allocateSubpage</span></span><br><span class="line">    <span class="keyword">if</span> ((normCapacity &amp; subpageOverflowMask) != <span class="number">0</span>) &#123; <span class="comment">// &gt;= pageSize</span></span><br><span class="line">        handle =  allocateRun(normCapacity);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        handle = allocateSubpage(normCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// handle是分配的id，小于0则分配失败</span></span><br><span class="line">    <span class="keyword">if</span> (handle &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从缓存中取出buffer</span></span><br><span class="line">    ByteBuffer nioBuffer = cachedNioBuffers != <span class="keyword">null</span> ? cachedNioBuffers.pollLast() : <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    initBuf(buf, nioBuffer, handle, reqCapacity);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="allocateRun"><a href="#allocateRun" class="headerlink" title="allocateRun"></a>allocateRun</h4><p>allocateRun分配的空间大于等于pageSize的方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">allocateRun</span><span class="params">(<span class="keyword">int</span> normCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 最大树高 - (normCapacity的幂 - 从1开始左移到页大小的位置，默认13，1&lt;&lt;13 = 8192)</span></span><br><span class="line">    <span class="comment">// d是满足normCapacity容量需要的树高</span></span><br><span class="line">    <span class="keyword">int</span> d = maxOrder - (log2(normCapacity) - pageShifts);</span><br><span class="line">    <span class="comment">// 根据树高分配节点</span></span><br><span class="line">    <span class="keyword">int</span> id = allocateNode(d);</span><br><span class="line">    <span class="keyword">if</span> (id &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算剩余容量</span></span><br><span class="line">    freeBytes -= runLength(id);</span><br><span class="line">    <span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>计算这个空间需要的树高d；</li>
<li>分配对应的节点；</li>
<li>计算剩余空间freeBytes；</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">runLength</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 很好理解, 2^24=16M, 而x层每一个节点的大小为2^(24-depth)</span></span><br><span class="line">    <span class="comment">// 16M=2^(24-0),那么x层的节点大小为2^(24-depth(id)),比如depth=2,算出来2^22=4M</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> &lt;&lt; log2ChunkSize - depth(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="allocateNode"><a href="#allocateNode" class="headerlink" title="allocateNode"></a>allocateNode</h4><p>allocateNode分配满足树高的节点。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">allocateNode</span><span class="params">(<span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> id = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 小于等于1&lt;&lt;d的位为0，高于的位为1</span></span><br><span class="line">    <span class="keyword">int</span> initial = - (<span class="number">1</span> &lt;&lt; d); <span class="comment">// has last d bits = 0 and rest all = 1</span></span><br><span class="line">    <span class="comment">// 计算id为1的节点的实际分配情况</span></span><br><span class="line">    <span class="keyword">byte</span> val = value(id);</span><br><span class="line">    <span class="keyword">if</span> (val &gt; d) &#123; <span class="comment">// unusable</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 找到val == d的节点，且树高最大的节点</span></span><br><span class="line">    <span class="comment">// (id &amp; initial) == 0 用于父节点和字节点的树高值相同的情况去获取最底层（初始树高最大）的节点</span></span><br><span class="line">    <span class="comment">// 父节点和字节点的树高值相同即有一个子节点已经被分配了</span></span><br><span class="line">    <span class="keyword">while</span> (val &lt; d || (id &amp; initial) == <span class="number">0</span>) &#123; <span class="comment">// id &amp; initial == 1 &lt;&lt; d for all ids at depth d, for &lt; d it is 0</span></span><br><span class="line">        <span class="comment">// &lt;&lt;1 扩大2倍，即为查找当前节点的左节点</span></span><br><span class="line">        id &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        val = value(id);</span><br><span class="line">        <span class="keyword">if</span> (val &gt; d) &#123;</span><br><span class="line">            <span class="comment">// +1 当前节点的兄弟节点</span></span><br><span class="line">            id ^= <span class="number">1</span>;</span><br><span class="line">            val = value(id);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">byte</span> value = value(id);</span><br><span class="line">    <span class="keyword">assert</span> value == d &amp;&amp; (id &amp; initial) == <span class="number">1</span> &lt;&lt; d : String.format(<span class="string">"val = %d, id &amp; initial = %d, d = %d"</span>,</span><br><span class="line">            value, id &amp; initial, d);</span><br><span class="line">    <span class="comment">// 设置节点为已分配</span></span><br><span class="line">    setValue(id, unusable); <span class="comment">// mark as unusable</span></span><br><span class="line">    <span class="comment">// 更新父节点的树高信息</span></span><br><span class="line">    updateParentsAlloc(id);</span><br><span class="line">    <span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>从id=1开始判断树高是否满足；</li>
<li>获取到实际树高满足的节点；</li>
<li>将节点设置成已分配（unusable）；</li>
<li>更新分配节点的父节点的树高；</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateParentsAlloc</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (id &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> parentId = id &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">byte</span> val1 = value(id);</span><br><span class="line">        <span class="keyword">byte</span> val2 = value(id ^ <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 父节点的树高取其子节点中的最小值</span></span><br><span class="line">        <span class="keyword">byte</span> val = val1 &lt; val2 ? val1 : val2;</span><br><span class="line">        setValue(parentId, val);</span><br><span class="line">        id = parentId;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>循环更新父节点-&gt;父节点的父节点-&gt;…的树高信息，的树高取其子节点中的最小值。</p>
<h4 id="allocateSubpage"><a href="#allocateSubpage" class="headerlink" title="allocateSubpage"></a>allocateSubpage</h4><p>allocateSubpage是分配小于pageSize的空间。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">allocateSubpage</span><span class="params">(<span class="keyword">int</span> normCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// arena根据空间大小判断是tiny还是small，然后从对应的队列中返回PoolSubpage head</span></span><br><span class="line">    PoolSubpage&lt;T&gt; head = arena.findSubpagePoolHead(normCapacity);</span><br><span class="line">    <span class="comment">// 只能从叶子节点上查找</span></span><br><span class="line">    <span class="keyword">int</span> d = maxOrder; </span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    <span class="keyword">synchronized</span> (head) &#123;</span><br><span class="line">        <span class="comment">// 分配节点</span></span><br><span class="line">        <span class="keyword">int</span> id = allocateNode(d);</span><br><span class="line">        <span class="keyword">if</span> (id &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> id;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> PoolSubpage&lt;T&gt;[] subpages = <span class="keyword">this</span>.subpages;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> pageSize = <span class="keyword">this</span>.pageSize;</span><br><span class="line"></span><br><span class="line">        freeBytes -= pageSize;</span><br><span class="line">        <span class="comment">// 计算在subPage数组上的位置</span></span><br><span class="line">        <span class="comment">// 得到叶子节点的偏移索引，从0开始，即2048-0,2049-1,...</span></span><br><span class="line">        <span class="keyword">int</span> subpageIdx = subpageIdx(id);</span><br><span class="line">        PoolSubpage&lt;T&gt; subpage = subpages[subpageIdx];</span><br><span class="line">        <span class="comment">// 将这个subpage插入到head后面</span></span><br><span class="line">        <span class="keyword">if</span> (subpage == <span class="keyword">null</span>) &#123;</span><br><span class="line">            subpage = <span class="keyword">new</span> PoolSubpage&lt;T&gt;(head, <span class="keyword">this</span>, id, runOffset(id), pageSize, normCapacity);</span><br><span class="line">            subpages[subpageIdx] = subpage;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            subpage.init(head, normCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> subpage.allocate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>获取arena中的PoolSubpage链表的头；</li>
<li>加锁；</li>
<li>分配page节点（只能从叶子节点中分配）；</li>
<li>计算剩余空间；</li>
<li>计算在subPage数组上的位置；</li>
<li>获取chunk的subpages中的SubPage对象；</li>
<li>如果SubPage对象存在则执行init，不然则new一个对象；</li>
<li>执行SubPage对象的allocate方法。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 得到叶子节点的偏移索引，从0开始，即2048-0,2049-1,...</span></span><br><span class="line"><span class="comment">// maxSubpageAllocs = 1 &lt;&lt; maxOrder</span></span><br><span class="line"><span class="comment">// 得到第11层节点的偏移索引，= id - 2048</span></span><br><span class="line"><span class="comment">// id &lt; (1 &lt;&lt; (maxOrder+1))</span></span><br><span class="line"><span class="comment">// 所以只会保留低于1 &lt;&lt; maxOrder的位</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">subpageIdx</span><span class="params">(<span class="keyword">int</span> memoryMapIdx)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> memoryMapIdx ^ maxSubpageAllocs; <span class="comment">// remove highest set bit, to get offset</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="initBuf"><a href="#initBuf" class="headerlink" title="initBuf"></a>initBuf</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initBuf</span><span class="params">(PooledByteBuf&lt;T&gt; buf, ByteBuffer nioBuffer, <span class="keyword">long</span> handle, <span class="keyword">int</span> reqCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// memoryMapIdx = (int)handle</span></span><br><span class="line">    <span class="keyword">int</span> memoryMapIdx = memoryMapIdx(handle);</span><br><span class="line">    <span class="comment">// bitmapIdx就是handle的高32位</span></span><br><span class="line">    <span class="keyword">int</span> bitmapIdx = bitmapIdx(handle);</span><br><span class="line">    <span class="keyword">if</span> (bitmapIdx == <span class="number">0</span>) &#123; <span class="comment">// 如果高32位0则为page，不然就是分配了subPage</span></span><br><span class="line">        <span class="keyword">byte</span> val = value(memoryMapIdx);</span><br><span class="line">        <span class="keyword">assert</span> val == unusable : String.valueOf(val);</span><br><span class="line">        <span class="comment">// 偏移量：节点的偏移量（id ^ 1 &lt;&lt; depth(id)）*分配的大小 + offset</span></span><br><span class="line">        buf.init(<span class="keyword">this</span>, nioBuffer, handle, runOffset(memoryMapIdx) + offset,</span><br><span class="line">                reqCapacity, runLength(memoryMapIdx), arena.parent.threadCache());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        initBufWithSubpage(buf, nioBuffer, handle, bitmapIdx, reqCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>subPage的初始化，两种的区别主要是最终buf初始化的偏移量不一样。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initBufWithSubpage</span><span class="params">(PooledByteBuf&lt;T&gt; buf, ByteBuffer nioBuffer,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">long</span> handle, <span class="keyword">int</span> bitmapIdx, <span class="keyword">int</span> reqCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> bitmapIdx != <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> memoryMapIdx = memoryMapIdx(handle);</span><br><span class="line"></span><br><span class="line">    PoolSubpage&lt;T&gt; subpage = subpages[subpageIdx(memoryMapIdx)];</span><br><span class="line">    <span class="keyword">assert</span> subpage.doNotDestroy;</span><br><span class="line">    <span class="keyword">assert</span> reqCapacity &lt;= subpage.elemSize;</span><br><span class="line"></span><br><span class="line">    buf.init(</span><br><span class="line">        <span class="keyword">this</span>, nioBuffer, handle,</span><br><span class="line">        偏移量：节点的偏移量（id ^ <span class="number">1</span> &lt;&lt; depth(id)）*分配的大小+ subPage的偏移量*大小 + offset</span><br><span class="line">        runOffset(memoryMapIdx) + (bitmapIdx &amp; <span class="number">0x3FFFFFFF</span>) * subpage.elemSize + offset,</span><br><span class="line">            reqCapacity, subpage.elemSize, arena.parent.threadCache());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="内存释放"><a href="#内存释放" class="headerlink" title="内存释放"></a>内存释放</h3><h4 id="free"><a href="#free" class="headerlink" title="free"></a>free</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">(<span class="keyword">long</span> handle, ByteBuffer nioBuffer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> memoryMapIdx = memoryMapIdx(handle);</span><br><span class="line">    <span class="keyword">int</span> bitmapIdx = bitmapIdx(handle);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bitmapIdx != <span class="number">0</span>) &#123; <span class="comment">// free a subpage</span></span><br><span class="line">        PoolSubpage&lt;T&gt; subpage = subpages[subpageIdx(memoryMapIdx)];</span><br><span class="line">        <span class="keyword">assert</span> subpage != <span class="keyword">null</span> &amp;&amp; subpage.doNotDestroy;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Obtain the head of the PoolSubPage pool that is owned by the PoolArena and synchronize on it.</span></span><br><span class="line">        <span class="comment">// This is need as we may add it back and so alter the linked-list structure.</span></span><br><span class="line">        PoolSubpage&lt;T&gt; head = arena.findSubpagePoolHead(subpage.elemSize);</span><br><span class="line">        <span class="keyword">synchronized</span> (head) &#123;</span><br><span class="line">            <span class="comment">// subPage的free方法</span></span><br><span class="line">            <span class="keyword">if</span> (subpage.free(head, bitmapIdx &amp; <span class="number">0x3FFFFFFF</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    freeBytes += runLength(memoryMapIdx);</span><br><span class="line">    <span class="comment">// 将该节点的树高设置为初始值</span></span><br><span class="line">    setValue(memoryMapIdx, depth(memoryMapIdx));</span><br><span class="line">    <span class="comment">// 更新父节点</span></span><br><span class="line">    updateParentsFree(memoryMapIdx);</span><br><span class="line">    <span class="comment">// 将nioBuffer存入队列</span></span><br><span class="line">    <span class="keyword">if</span> (nioBuffer != <span class="keyword">null</span> &amp;&amp; cachedNioBuffers != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">            cachedNioBuffers.size() &lt; PooledByteBufAllocator.DEFAULT_MAX_CACHED_BYTEBUFFERS_PER_CHUNK) &#123;</span><br><span class="line">        cachedNioBuffers.offer(nioBuffer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="updateParentsFree"><a href="#updateParentsFree" class="headerlink" title="updateParentsFree"></a>updateParentsFree</h4><p>updateParentsFree更新父节点的val，如果两个子节点都被释放了则将父节点更新成初始高度，不然更新为两个子节点中的最小值。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateParentsFree</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> logChild = depth(id) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (id &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> parentId = id &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">byte</span> val1 = value(id);</span><br><span class="line">        <span class="keyword">byte</span> val2 = value(id ^ <span class="number">1</span>);</span><br><span class="line">        logChild -= <span class="number">1</span>; <span class="comment">// in first iteration equals log, subsequently reduce 1 from logChild as we traverse up</span></span><br><span class="line">        <span class="comment">// 两个子节点都释放了，则设置为初始值</span></span><br><span class="line">        <span class="keyword">if</span> (val1 == logChild &amp;&amp; val2 == logChild) &#123;</span><br><span class="line">            setValue(parentId, (<span class="keyword">byte</span>) (logChild - <span class="number">1</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">byte</span> val = val1 &lt; val2 ? val1 : val2;</span><br><span class="line">            setValue(parentId, val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        id = parentId;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.jianshu.com/p/70181af2972a" target="_blank" rel="noopener">自顶向下深入分析Netty（十）–PoolChunk</a></p>
</div><div class="tags"><a href="/tags/网络/">网络</a><a href="/tags/Netty/">Netty</a><a href="/tags/内存/">内存</a></div><div class="post-nav"><a class="pre" href="/2020/03/12/Netty之旅25PoolSubpage/">Netty解析二十三：Netty内存分配PoolSubpage</a><a class="next" href="/2020/03/05/Netty之旅23内存分配模型/">Netty解析二十一：Netty内存分配模型</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="https://SvizzerChow.github.io"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Netty/">Netty</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Sentinel/">Sentinel</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/kafka/">kafka</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/redis/">redis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/sharding-jdbc/">sharding-jdbc</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/分布式/">分布式</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/并发/">并发</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据库/">数据库</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法/">算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/线程池/">线程池</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/网络/">网络</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/虚拟机/">虚拟机</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/源码解析/" style="font-size: 15px;">源码解析</a> <a href="/tags/BASE理论/" style="font-size: 15px;">BASE理论</a> <a href="/tags/虚拟机/" style="font-size: 15px;">虚拟机</a> <a href="/tags/JavaAgent/" style="font-size: 15px;">JavaAgent</a> <a href="/tags/集合/" style="font-size: 15px;">集合</a> <a href="/tags/可见性/" style="font-size: 15px;">可见性</a> <a href="/tags/内存模型/" style="font-size: 15px;">内存模型</a> <a href="/tags/MESI/" style="font-size: 15px;">MESI</a> <a href="/tags/volatile/" style="font-size: 15px;">volatile</a> <a href="/tags/MySQL/" style="font-size: 15px;">MySQL</a> <a href="/tags/网络/" style="font-size: 15px;">网络</a> <a href="/tags/Netty/" style="font-size: 15px;">Netty</a> <a href="/tags/channel/" style="font-size: 15px;">channel</a> <a href="/tags/ServerBootstrap/" style="font-size: 15px;">ServerBootstrap</a> <a href="/tags/NioEventLoop/" style="font-size: 15px;">NioEventLoop</a> <a href="/tags/启动/" style="font-size: 15px;">启动</a> <a href="/tags/线程模型/" style="font-size: 15px;">线程模型</a> <a href="/tags/读写事件/" style="font-size: 15px;">读写事件</a> <a href="/tags/http/" style="font-size: 15px;">http</a> <a href="/tags/沾包/" style="font-size: 15px;">沾包</a> <a href="/tags/拆包/" style="font-size: 15px;">拆包</a> <a href="/tags/内存/" style="font-size: 15px;">内存</a> <a href="/tags/NIO/" style="font-size: 15px;">NIO</a> <a href="/tags/redis/" style="font-size: 15px;">redis</a> <a href="/tags/NoSQL/" style="font-size: 15px;">NoSQL</a> <a href="/tags/限流/" style="font-size: 15px;">限流</a> <a href="/tags/降级/" style="font-size: 15px;">降级</a> <a href="/tags/熔断/" style="font-size: 15px;">熔断</a> <a href="/tags/Sentinel/" style="font-size: 15px;">Sentinel</a> <a href="/tags/CAP理论/" style="font-size: 15px;">CAP理论</a> <a href="/tags/TCP/" style="font-size: 15px;">TCP</a> <a href="/tags/kafka/" style="font-size: 15px;">kafka</a> <a href="/tags/生产者/" style="font-size: 15px;">生产者</a> <a href="/tags/原子性/" style="font-size: 15px;">原子性</a> <a href="/tags/long/" style="font-size: 15px;">long</a> <a href="/tags/double/" style="font-size: 15px;">double</a> <a href="/tags/并发/" style="font-size: 15px;">并发</a> <a href="/tags/sentinel/" style="font-size: 15px;">sentinel</a> <a href="/tags/zookeeper/" style="font-size: 15px;">zookeeper</a> <a href="/tags/数据库/" style="font-size: 15px;">数据库</a> <a href="/tags/分库分表/" style="font-size: 15px;">分库分表</a> <a href="/tags/io/" style="font-size: 15px;">io</a> <a href="/tags/同步/" style="font-size: 15px;">同步</a> <a href="/tags/异步/" style="font-size: 15px;">异步</a> <a href="/tags/分布式锁/" style="font-size: 15px;">分布式锁</a> <a href="/tags/线程池/" style="font-size: 15px;">线程池</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/Excutors/" style="font-size: 15px;">Excutors</a> <a href="/tags/多线程/" style="font-size: 15px;">多线程</a> <a href="/tags/FutureTask/" style="font-size: 15px;">FutureTask</a> <a href="/tags/ThreadPoolExecutor/" style="font-size: 15px;">ThreadPoolExecutor</a> <a href="/tags/ScheduledThreadPoolExecutor/" style="font-size: 15px;">ScheduledThreadPoolExecutor</a> <a href="/tags/缓存/" style="font-size: 15px;">缓存</a> <a href="/tags/缓存行/" style="font-size: 15px;">缓存行</a> <a href="/tags/轮询/" style="font-size: 15px;">轮询</a> <a href="/tags/算法/" style="font-size: 15px;">算法</a> <a href="/tags/AbstractExecutorService/" style="font-size: 15px;">AbstractExecutorService</a> <a href="/tags/Spring/" style="font-size: 15px;">Spring</a> <a href="/tags/sharding-jdbc/" style="font-size: 15px;">sharding-jdbc</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/04/09/kafka生产者客户端发送逻辑简析/">kafka：生产者客户端发送逻辑简析</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/19/Netty之旅30对象池Recycler/">Netty解析二十八：Netty对象池Recycler</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/18/Netty之旅29PooledByteBufAllocator/">Netty解析二十七：Netty内存分配PooledByteBufAllocator</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/18/Netty之旅28PooledByteBuf/">Netty解析二十六：Netty内存分配PooledByteBuf</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/16/Netty之旅27PoolArena/">Netty解析二十五：Netty内存分配PoolArena</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/13/Netty之旅26PoolChunkList/">Netty解析二十四：Netty内存分配PoolChunkList</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/12/Netty之旅25PoolSubpage/">Netty解析二十三：Netty内存分配PoolSubpage</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/06/Netty之旅24PoolChunk/">Netty解析二十二：Netty内存分配PoolChunk</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/05/Netty之旅23内存分配模型/">Netty解析二十一：Netty内存分配模型</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/03/同步异步和阻塞非阻塞/">同步/异步与阻塞/非阻塞</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2017-2020 <a href="/." rel="nofollow">SvizzerChow's Blog.</a><a rel="nofollow" target="_blank" href="http://www.beian.miit.gov.cn"> 浙ICP备18053179号</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>