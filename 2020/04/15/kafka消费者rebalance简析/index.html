<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="我的个人博客"><title>kafka：消费者rebalance简析 | SvizzerChow's Blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">kafka：消费者rebalance简析</h1><a id="logo" href="/.">SvizzerChow's Blog</a><p class="description">Leaning</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">kafka：消费者rebalance简析</h1><div class="post-meta">Apr 15, 2020<span> | </span><span class="category"><a href="/categories/kafka/">kafka</a></span></div><div class="post-content"><meta name="referrer" content="no-referrer">

<p>kafka一个主题的一个分区在同一个group中只能被一个消费者消费，如果不是同一个group中的消费者可以同时消费。为了实现这个功能kafka需要管理和分配group中的消费分区。这一大块功能属于coordinator。</p>
<a id="more"></a>
<h2 id="关键字解释"><a href="#关键字解释" class="headerlink" title="关键字解释"></a>关键字解释</h2><h3 id="coordinator"><a href="#coordinator" class="headerlink" title="coordinator"></a>coordinator</h3><ul>
<li>Consumer Group用group.id(String)作为全局唯一标识符</li>
<li>每个Group可以有零个、一个或多个Consumer Client</li>
<li>每个Group可以管理零个、一个或多个Topic</li>
<li>Group下每个Consumer Client可同时订阅Topic的一个或多个Partition</li>
<li>Group下同一个Partition<strong>只能被一个Client订阅</strong>，多Group下的Client订阅不受影响；因为如果一个Partition有多个Consumer，那么每个Consumer在该Partition上的Offset很可能会不一致，这样会导致在Rebalance后赋值处理的Client的消费起点发生混乱；与此同时，这种场景也不符合Kafka中Partition消息消费的一致性；因此在同一Group下一个Partition只能对应一个Consumer Client。</li>
</ul>
<h3 id="rebalance"><a href="#rebalance" class="headerlink" title="rebalance"></a>rebalance</h3><p>它本质上是一种协议，规定了一个 Consumer Group 下的所有 consumer 如何达成一致，来分配订阅 Topic 的每个分区。例如：某 Group 下有 20 个 consumer 实例，它订阅了一个具有 100 个 partition 的 Topic 。正常情况下，kafka 会为每个 Consumer 平均的分配 5 个分区。这个分配的过程就是 Rebalance。</p>
<p>需要注意的是，rebalance过程中group内的所有consumer会停止消费，非常影响kafka的消费性能，所以需要尽量避免rebalance的发生。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/168294/1587019334662-assets/web-upload/fa29badf-8f4e-4519-b647-99b18cb2f04b.png" alt="rebalance协议简单示例"></p>
<h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><h3 id="消费者拉取消息过程"><a href="#消费者拉取消息过程" class="headerlink" title="消费者拉取消息过程"></a>消费者拉取消息过程</h3><p>消费者拉取消息是通过<code>KafkaConsumer.poll()</code>，这也是rebalance过程的一个入口。</p>
<p>前面的调用链就简化一下：</p>
<p>KafkaConsumer.poll(final Duration timeout)<br>-&gt; KafkaConsumer.poll(final Timer timer, final boolean includeMetadataInTimeout)<br>-&gt; KafkaConsumer.updateAssignmentMetadataIfNeeded<br>-&gt; coordinator.poll</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ConsumerRecords&lt;K, V&gt; <span class="title">poll</span><span class="params">(<span class="keyword">final</span> Duration timeout)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> poll(time.timer(timeout), <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> ConsumerRecords&lt;K, V&gt; <span class="title">poll</span><span class="params">(<span class="keyword">final</span> Timer timer, <span class="keyword">final</span> <span class="keyword">boolean</span> includeMetadataInTimeout)</span> </span>&#123;</span><br><span class="line">    acquireAndEnsureOpen();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.kafkaConsumerMetrics.recordPollStart(timer.currentTimeMs());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.subscriptions.hasNoSubscriptionOrUserAssignment()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Consumer is not subscribed to any topics or assigned any partitions"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// poll for new data until the timeout expires</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            client.maybeTriggerWakeup();</span><br><span class="line">            <span class="comment">// 默认为true</span></span><br><span class="line">            <span class="keyword">if</span> (includeMetadataInTimeout) &#123;</span><br><span class="line">                <span class="comment">// 在这里执行coordinator</span></span><br><span class="line">                <span class="keyword">if</span> (!updateAssignmentMetadataIfNeeded(timer)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> ConsumerRecords.empty();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                 <span class="comment">// 在这里执行coordinator</span></span><br><span class="line">                <span class="keyword">while</span> (!updateAssignmentMetadataIfNeeded(time.timer(Long.MAX_VALUE))) &#123;</span><br><span class="line">                    log.warn(<span class="string">"Still waiting for metadata"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> Map&lt;TopicPartition, List&lt;ConsumerRecord&lt;K, V&gt;&gt;&gt; records = pollForFetches(timer);</span><br><span class="line">            <span class="keyword">if</span> (!records.isEmpty()) &#123;</span><br><span class="line">                <span class="comment">// before returning the fetched records, we can send off the next round of fetches</span></span><br><span class="line">                <span class="comment">// and avoid block waiting for their responses to enable pipelining while the user</span></span><br><span class="line">                <span class="comment">// is handling the fetched records.</span></span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">                <span class="comment">// <span class="doctag">NOTE:</span> since the consumed position has already been updated, we must not allow</span></span><br><span class="line">                <span class="comment">// wakeups or any other errors to be triggered prior to returning the fetched records.</span></span><br><span class="line">                <span class="keyword">if</span> (fetcher.sendFetches() &gt; <span class="number">0</span> || client.hasPendingRequests()) &#123;</span><br><span class="line">                    client.transmitSends();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.interceptors.onConsume(<span class="keyword">new</span> ConsumerRecords&lt;&gt;(records));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (timer.notExpired());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ConsumerRecords.empty();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        release();</span><br><span class="line">        <span class="keyword">this</span>.kafkaConsumerMetrics.recordPollEnd(timer.currentTimeMs());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在KafkaConsumer.poll中会执行updateAssignmentMetadataIfNeeded方法，在这个方法里执行了coordinator的poll方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">updateAssignmentMetadataIfNeeded</span><span class="params">(<span class="keyword">final</span> Timer timer)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 执行poll方法</span></span><br><span class="line">    <span class="keyword">if</span> (coordinator != <span class="keyword">null</span> &amp;&amp; !coordinator.poll(timer)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> updateFetchPositions(timer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ConsumerCoordinator-poll"><a href="#ConsumerCoordinator-poll" class="headerlink" title="ConsumerCoordinator.poll"></a>ConsumerCoordinator.poll</h4><p>rebalance的核心是ensureActiveGroup方法，在ensureActiveGroup中会发起JoinGroup请求和SyncGroup请求。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">poll</span><span class="params">(Timer timer)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 元数据更新</span></span><br><span class="line">    maybeUpdateSubscriptionMetadata();</span><br><span class="line">    <span class="comment">// 完成已提交offset的回调</span></span><br><span class="line">    invokeCompletedOffsetCommitCallbacks();</span><br><span class="line">    <span class="comment">// 是自动分配partition模式</span></span><br><span class="line">    <span class="keyword">if</span> (subscriptions.partitionsAutoAssigned()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (protocol == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"User configured "</span> + ConsumerConfig.PARTITION_ASSIGNMENT_STRATEGY_CONFIG +</span><br><span class="line">                <span class="string">" to empty while trying to subscribe for group protocol to auto assign partitions"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Always update the heartbeat last poll time so that the heartbeat thread does not leave the</span></span><br><span class="line">        <span class="comment">// group proactively due to application inactivity even if (say) the coordinator cannot be found.</span></span><br><span class="line">        <span class="comment">// 更新心跳</span></span><br><span class="line">        pollHeartbeat(timer.currentTimeMs());</span><br><span class="line">        <span class="comment">// 找到对应的coordinator，并建立连接</span></span><br><span class="line">        <span class="keyword">if</span> (coordinatorUnknown() &amp;&amp; !ensureCoordinatorReady(timer)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断是否有需要rejoin group的情况发生</span></span><br><span class="line">        <span class="keyword">if</span> (rejoinNeededOrPending()) &#123;</span><br><span class="line">            <span class="comment">// rejoin group 之前先刷新一下 metadata（对于 AUTO_PATTERN 而言）</span></span><br><span class="line">            <span class="keyword">if</span> (subscriptions.hasPatternSubscription()) &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.metadata.timeToAllowUpdate(timer.currentTimeMs()) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.metadata.requestUpdate();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!client.ensureFreshMetadata(timer)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 需要是更新元数据</span></span><br><span class="line">                maybeUpdateSubscriptionMetadata();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 发起加入组请求和sync，进行rebalance</span></span><br><span class="line">            <span class="comment">// 创建心跳线程</span></span><br><span class="line">            <span class="keyword">if</span> (!ensureActiveGroup(timer)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// For manually assigned partitions, if there are no ready nodes, await metadata.</span></span><br><span class="line">        <span class="comment">// If connections to all nodes fail, wakeups triggered while attempting to send fetch</span></span><br><span class="line">        <span class="comment">// requests result in polls returning immediately, causing a tight loop of polls. Without</span></span><br><span class="line">        <span class="comment">// the wakeup, poll() with no channels would block for the timeout, delaying re-connection.</span></span><br><span class="line">        <span class="comment">// awaitMetadataUpdate() initiates new connections with configured backoff and avoids the busy loop.</span></span><br><span class="line">        <span class="comment">// When group management is used, metadata wait is already performed for this scenario as</span></span><br><span class="line">        <span class="comment">// coordinator is unknown, hence this check is not required.</span></span><br><span class="line">        <span class="keyword">if</span> (metadata.updateRequested() &amp;&amp; !client.hasReadyNodes(timer.currentTimeMs())) &#123;</span><br><span class="line">            client.awaitMetadataUpdate(timer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    maybeAutoCommitOffsetsAsync(timer.currentTimeMs());</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="invokeCompletedOffsetCommitCallbacks"><a href="#invokeCompletedOffsetCommitCallbacks" class="headerlink" title="invokeCompletedOffsetCommitCallbacks"></a>invokeCompletedOffsetCommitCallbacks</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">invokeCompletedOffsetCommitCallbacks</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (asyncCommitFenced.get()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> FencedInstanceIdException(<span class="string">"Get fenced exception for group.instance.id "</span></span><br><span class="line">            + rebalanceConfig.groupInstanceId.orElse(<span class="string">"unset_instance_id"</span>)</span><br><span class="line">            + <span class="string">", current member.id is "</span> + memberId());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 取出完成的commit offect的回调</span></span><br><span class="line">        OffsetCommitCompletion completion = completedOffsetCommits.poll();</span><br><span class="line">        <span class="keyword">if</span> (completion == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        completion.invoke();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="pollHeartbeat"><a href="#pollHeartbeat" class="headerlink" title="pollHeartbeat"></a>pollHeartbeat</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">pollHeartbeat</span><span class="params">(<span class="keyword">long</span> now)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (heartbeatThread != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (heartbeatThread.hasFailed()) &#123;</span><br><span class="line">            <span class="comment">// set the heartbeat thread to null and raise an exception. If the user catches it,</span></span><br><span class="line">            <span class="comment">// the next call to ensureActiveGroup() will spawn a new heartbeat thread.</span></span><br><span class="line">            RuntimeException cause = heartbeatThread.failureCause();</span><br><span class="line">            heartbeatThread = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">throw</span> cause;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Awake the heartbeat thread if needed</span></span><br><span class="line">        <span class="keyword">if</span> (heartbeat.shouldHeartbeat(now)) &#123;</span><br><span class="line">            notify();</span><br><span class="line">        &#125;</span><br><span class="line">        heartbeat.poll(now);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="确保coordinator服务处于ready状态ensureCoordinatorReady"><a href="#确保coordinator服务处于ready状态ensureCoordinatorReady" class="headerlink" title="确保coordinator服务处于ready状态ensureCoordinatorReady"></a>确保coordinator服务处于ready状态ensureCoordinatorReady</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">ensureCoordinatorReady</span><span class="params">(<span class="keyword">final</span> Timer timer)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 已经确定coordinator服务了</span></span><br><span class="line">    <span class="keyword">if</span> (!coordinatorUnknown())</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 循环查找</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 发起查找请求</span></span><br><span class="line">        <span class="keyword">final</span> RequestFuture&lt;Void&gt; future = lookupCoordinator();</span><br><span class="line">        <span class="comment">// 发送请求</span></span><br><span class="line">        client.poll(future, timer);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!future.isDone()) &#123;</span><br><span class="line">            <span class="comment">// ran out of time</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (future.failed()) &#123;</span><br><span class="line">            <span class="comment">// 查找失败更新元数据</span></span><br><span class="line">            <span class="keyword">if</span> (future.isRetriable()) &#123;</span><br><span class="line">                log.debug(<span class="string">"Coordinator discovery failed, refreshing metadata"</span>);</span><br><span class="line">                client.awaitMetadataUpdate(timer);</span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">throw</span> future.exception();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (coordinator != <span class="keyword">null</span> &amp;&amp; client.isUnavailable(coordinator)) &#123;<span class="comment">// 找到但是不可用</span></span><br><span class="line">            <span class="comment">// we found the coordinator, but the connection has failed, so mark</span></span><br><span class="line">            <span class="comment">// it dead and backoff before retrying discovery</span></span><br><span class="line">            <span class="comment">// 标记为空</span></span><br><span class="line">            markCoordinatorUnknown();</span><br><span class="line">            timer.sleep(rebalanceConfig.retryBackoffMs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (coordinatorUnknown() &amp;&amp; timer.notExpired());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> !coordinatorUnknown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查找Coordinator节点<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> RequestFuture&lt;Void&gt; <span class="title">lookupCoordinator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (findCoordinatorFuture == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// find a node to ask about the coordinator</span></span><br><span class="line">        <span class="comment">// 选择负载最小的节点</span></span><br><span class="line">        Node node = <span class="keyword">this</span>.client.leastLoadedNode();</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            log.debug(<span class="string">"No broker available to send FindCoordinator request"</span>);</span><br><span class="line">            <span class="keyword">return</span> RequestFuture.noBrokersAvailable();</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            findCoordinatorFuture = sendFindCoordinatorRequest(node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> findCoordinatorFuture;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 发起查找Coordinator节点的请求</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> RequestFuture&lt;Void&gt; <span class="title">sendFindCoordinatorRequest</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// initiate the group metadata request</span></span><br><span class="line">    log.debug(<span class="string">"Sending FindCoordinator request to broker &#123;&#125;"</span>, node);</span><br><span class="line">    FindCoordinatorRequest.Builder requestBuilder =</span><br><span class="line">            <span class="keyword">new</span> FindCoordinatorRequest.Builder(</span><br><span class="line">                    <span class="keyword">new</span> FindCoordinatorRequestData()</span><br><span class="line">                        .setKeyType(CoordinatorType.GROUP.id())</span><br><span class="line">                        .setKey(<span class="keyword">this</span>.rebalanceConfig.groupId));</span><br><span class="line">    <span class="keyword">return</span> client.send(node, requestBuilder)</span><br><span class="line">            .compose(<span class="keyword">new</span> FindCoordinatorResponseHandler());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>查找Coordinator会先发生一个查找请求到当前负载最小broker节点上，然后broker会计算当前组所属的Coordinator节点是哪个；这个计算逻辑是根据groupId的hash值对__consumer_offset_主题的分区数取余，这个分区所在的broker也就是这个group的Coordinator</strong></p>
<blockquote>
<p>Utils.abs(groupId.hashCode) % groupMetadataTopicPartitionCount</p>
</blockquote>
<p>这也意味着这个group的所有消息的offset信息都会记录在这个__consumer_offset_主题的这个分区中。</p>
<p>__consumer_offset_主题的默认分区数是50。</p>
<h5 id="needRejoin-是否需要rebalance"><a href="#needRejoin-是否需要rebalance" class="headerlink" title="needRejoin 是否需要rebalance"></a>needRejoin 是否需要rebalance</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">rejoinNeededOrPending</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!subscriptions.partitionsAutoAssigned())</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// we need to rejoin if we performed the assignment and metadata has changed;</span></span><br><span class="line">    <span class="comment">// also for those owned-but-no-longer-existed partitions we should drop them as lost</span></span><br><span class="line">    <span class="keyword">if</span> (assignmentSnapshot != <span class="keyword">null</span> &amp;&amp; !assignmentSnapshot.matches(metadataSnapshot))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// we need to join if our subscription has changed since the last join</span></span><br><span class="line">    <span class="keyword">if</span> (joinedSubscription != <span class="keyword">null</span> &amp;&amp; !joinedSubscription.equals(subscriptions.subscription())) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.rejoinNeededOrPending();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只有auto assign模式的才可能需要，如果订阅的topic list发生变化、订阅的topic的partition发生变化，就需要rejoin，也就是要进行rebalance过程，其实还有个条件会触发，就是当group里有新的consumer加入或者有consumer主动退出或挂掉。</p>
<h5 id="rebalance核心ensureActiveGroup"><a href="#rebalance核心ensureActiveGroup" class="headerlink" title="rebalance核心ensureActiveGroup"></a>rebalance核心ensureActiveGroup</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">ensureActiveGroup</span><span class="params">(<span class="keyword">final</span> Timer timer)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 再次确认是否准备好了</span></span><br><span class="line">    <span class="keyword">if</span> (!ensureCoordinatorReady(timer)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 没有心跳线程则开启</span></span><br><span class="line">    startHeartbeatThreadIfNeeded();</span><br><span class="line">    <span class="comment">// 加入组</span></span><br><span class="line">    <span class="keyword">return</span> joinGroupIfNeeded(timer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="开启心跳线程startHeartbeatThreadIfNeeded"><a href="#开启心跳线程startHeartbeatThreadIfNeeded" class="headerlink" title="开启心跳线程startHeartbeatThreadIfNeeded"></a>开启心跳线程startHeartbeatThreadIfNeeded</h6><p>开启单独的心跳处理线程<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">startHeartbeatThreadIfNeeded</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (heartbeatThread == <span class="keyword">null</span>) &#123;</span><br><span class="line">        heartbeatThread = <span class="keyword">new</span> HeartbeatThread();</span><br><span class="line">        heartbeatThread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="加入组joinGroupIfNeeded"><a href="#加入组joinGroupIfNeeded" class="headerlink" title="加入组joinGroupIfNeeded"></a>加入组joinGroupIfNeeded</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">joinGroupIfNeeded</span><span class="params">(<span class="keyword">final</span> Timer timer)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 需要重新加入</span></span><br><span class="line">    <span class="keyword">while</span> (rejoinNeededOrPending()) &#123;</span><br><span class="line">        <span class="comment">// Coordinator找到且准备好</span></span><br><span class="line">        <span class="keyword">if</span> (!ensureCoordinatorReady(timer)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// call onJoinPrepare if needed. We set a flag to make sure that we do not call it a second</span></span><br><span class="line">        <span class="comment">// time if the client is woken up before a pending rebalance completes. This must be called</span></span><br><span class="line">        <span class="comment">// on each iteration of the loop because an event requiring a rebalance (such as a metadata</span></span><br><span class="line">        <span class="comment">// refresh which changes the matched subscription set) can occur while another rebalance is</span></span><br><span class="line">        <span class="comment">// still in progress.</span></span><br><span class="line">        <span class="comment">// 避免中途唤醒的情况</span></span><br><span class="line">        <span class="keyword">if</span> (needsJoinPrepare) &#123;</span><br><span class="line">            <span class="comment">// need to set the flag before calling onJoinPrepare since the user callback may throw</span></span><br><span class="line">            <span class="comment">// exception, in which case upon retry we should not retry onJoinPrepare either.</span></span><br><span class="line">            needsJoinPrepare = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// 加入组的前期准备/处理</span></span><br><span class="line">            <span class="comment">// 这里会回调rebalance监听器</span></span><br><span class="line">            onJoinPrepare(generation.generationId, generation.memberId);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 发送JoinGroup请求</span></span><br><span class="line">        <span class="comment">// 请求的响应会通过JoinGroupResponseHandler来处理</span></span><br><span class="line">        <span class="comment">// 在JoinGroupResponseHandler中会根据响应发起SyncGroup请求</span></span><br><span class="line">        <span class="keyword">final</span> RequestFuture&lt;ByteBuffer&gt; future = initiateJoinGroup();</span><br><span class="line">        client.poll(future, timer);</span><br><span class="line">        <span class="keyword">if</span> (!future.isDone()) &#123;</span><br><span class="line">            <span class="comment">// we ran out of time</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 加入组成功</span></span><br><span class="line">        <span class="keyword">if</span> (future.succeeded()) &#123;</span><br><span class="line">            Generation generationSnapshot;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Generation data maybe concurrently cleared by Heartbeat thread.</span></span><br><span class="line">            <span class="comment">// Can't use synchronized for &#123;@code onJoinComplete&#125;, because it can be long enough</span></span><br><span class="line">            <span class="comment">// and  shouldn't block hearbeat thread.</span></span><br><span class="line">            <span class="comment">// See &#123;@link PlaintextConsumerTest#testMaxPollIntervalMsDelayInAssignment</span></span><br><span class="line">            <span class="keyword">synchronized</span> (AbstractCoordinator.<span class="keyword">this</span>) &#123;</span><br><span class="line">                generationSnapshot = <span class="keyword">this</span>.generation;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (generationSnapshot != Generation.NO_GENERATION) &#123;</span><br><span class="line">                <span class="comment">// Duplicate the buffer in case `onJoinComplete` does not complete and needs to be retried.</span></span><br><span class="line">                ByteBuffer memberAssignment = future.value().duplicate();</span><br><span class="line">                <span class="comment">// 入组成功的回调</span></span><br><span class="line">                <span class="comment">// 重新订阅主题</span></span><br><span class="line">                onJoinComplete(generationSnapshot.generationId, generationSnapshot.memberId, generationSnapshot.protocol, memberAssignment);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Generally speaking we should always resetJoinGroupFuture once the future is done, but here</span></span><br><span class="line">                <span class="comment">// we can only reset the join group future after the completion callback returns. This ensures</span></span><br><span class="line">                <span class="comment">// that if the callback is woken up, we will retry it on the next joinGroupIfNeeded.</span></span><br><span class="line">                <span class="comment">// And because of that we should explicitly trigger resetJoinGroupFuture in other conditions below.</span></span><br><span class="line">                resetJoinGroupFuture();</span><br><span class="line">                needsJoinPrepare = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                log.info(<span class="string">"Generation data was cleared by heartbeat thread. Initiating rejoin."</span>);</span><br><span class="line">                resetStateAndRejoin();</span><br><span class="line">                resetJoinGroupFuture();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 失败了重新加入</span></span><br><span class="line">            resetJoinGroupFuture();</span><br><span class="line">            <span class="keyword">final</span> RuntimeException exception = future.exception();</span><br><span class="line">            <span class="keyword">if</span> (exception <span class="keyword">instanceof</span> UnknownMemberIdException ||</span><br><span class="line">                    exception <span class="keyword">instanceof</span> RebalanceInProgressException ||</span><br><span class="line">                    exception <span class="keyword">instanceof</span> IllegalGenerationException ||</span><br><span class="line">                    exception <span class="keyword">instanceof</span> MemberIdRequiredException)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!future.isRetriable())</span><br><span class="line">                <span class="keyword">throw</span> exception;</span><br><span class="line">            <span class="comment">// 重试延时</span></span><br><span class="line">            timer.sleep(rebalanceConfig.retryBackoffMs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="加入组的前期准备-处理onJoinPrepare"><a href="#加入组的前期准备-处理onJoinPrepare" class="headerlink" title="加入组的前期准备/处理onJoinPrepare"></a>加入组的前期准备/处理onJoinPrepare</h6><p>加入组的前期准备/处理<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onJoinPrepare</span><span class="params">(<span class="keyword">int</span> generation, String memberId)</span> </span>&#123;</span><br><span class="line">    log.debug(<span class="string">"Executing onJoinPrepare with generation &#123;&#125; and memberId &#123;&#125;"</span>, generation, memberId);</span><br><span class="line">    <span class="comment">// commit offsets prior to rebalance if auto-commit enabled</span></span><br><span class="line">    <span class="comment">// 开启自动提交则先提交offset</span></span><br><span class="line">    maybeAutoCommitOffsetsSync(time.timer(rebalanceConfig.rebalanceTimeoutMs));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the generation / member-id can possibly be reset by the heartbeat thread</span></span><br><span class="line">    <span class="comment">// upon getting errors or heartbeat timeouts; in this case whatever is previously</span></span><br><span class="line">    <span class="comment">// owned partitions would be lost, we should trigger the callback and cleanup the assignment;</span></span><br><span class="line">    <span class="comment">// otherwise we can proceed normally and revoke the partitions depending on the protocol,</span></span><br><span class="line">    <span class="comment">// and in that case we should only change the assignment AFTER the revoke callback is triggered</span></span><br><span class="line">    <span class="comment">// so that users can still access the previously owned partitions to commit offsets etc.</span></span><br><span class="line">    <span class="comment">// 错误或心跳超时时，心跳线程可能会重置generation / member-id</span></span><br><span class="line">    <span class="comment">// 这个时候清理订阅的主题</span></span><br><span class="line">    Exception exception = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">final</span> Set&lt;TopicPartition&gt; revokedPartitions;</span><br><span class="line">    <span class="keyword">if</span> (generation == Generation.NO_GENERATION.generationId &amp;&amp;</span><br><span class="line">        memberId.equals(Generation.NO_GENERATION.memberId)) &#123;</span><br><span class="line">        revokedPartitions = <span class="keyword">new</span> HashSet&lt;&gt;(subscriptions.assignedPartitions());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!revokedPartitions.isEmpty()) &#123;</span><br><span class="line">            log.info(<span class="string">"Giving away all assigned partitions as lost since generation has been reset,"</span> +</span><br><span class="line">                <span class="string">"indicating that consumer is no longer part of the group"</span>);</span><br><span class="line">            exception = invokePartitionsLost(revokedPartitions);</span><br><span class="line">            <span class="comment">// 清空订阅</span></span><br><span class="line">            subscriptions.assignFromSubscribed(Collections.emptySet());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (protocol) &#123;</span><br><span class="line">            <span class="keyword">case</span> EAGER:</span><br><span class="line">                <span class="comment">// revoke all partitions</span></span><br><span class="line">                revokedPartitions = <span class="keyword">new</span> HashSet&lt;&gt;(subscriptions.assignedPartitions());</span><br><span class="line">                exception = invokePartitionsRevoked(revokedPartitions);</span><br><span class="line"></span><br><span class="line">                subscriptions.assignFromSubscribed(Collections.emptySet());</span><br><span class="line"></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> COOPERATIVE:</span><br><span class="line">                <span class="comment">// only revoke those partitions that are not in the subscription any more.</span></span><br><span class="line">                Set&lt;TopicPartition&gt; ownedPartitions = <span class="keyword">new</span> HashSet&lt;&gt;(subscriptions.assignedPartitions());</span><br><span class="line">                revokedPartitions = ownedPartitions.stream()</span><br><span class="line">                    .filter(tp -&gt; !subscriptions.subscription().contains(tp.topic()))</span><br><span class="line">                    .collect(Collectors.toSet());</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!revokedPartitions.isEmpty()) &#123;</span><br><span class="line">                    <span class="comment">// 执行rebalance监听器回调</span></span><br><span class="line">                    exception = invokePartitionsRevoked(revokedPartitions);</span><br><span class="line"></span><br><span class="line">                    ownedPartitions.removeAll(revokedPartitions);</span><br><span class="line">                    <span class="comment">// 清理订阅</span></span><br><span class="line">                    subscriptions.assignFromSubscribed(ownedPartitions);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    isLeader = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 更新组信息，groupSubscription = Collections.emptySet()</span></span><br><span class="line">    subscriptions.resetGroupSubscription();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (exception != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> KafkaException(<span class="string">"User rebalance callback throws an error"</span>, exception);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="加入组响应处理JoinGroupResponseHandler"><a href="#加入组响应处理JoinGroupResponseHandler" class="headerlink" title="加入组响应处理JoinGroupResponseHandler"></a>加入组响应处理JoinGroupResponseHandler</h6><p>在JoinGroupResponseHandler响应处理器中，根据响应信息判断当前节点是不是leader节点；如果是leader节点则对组内节点分配分区，发起SyncGroup请求将分区结果带给coordinator节点；如果不是leader节点，则发起SyncGroup请求没有分区分配信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(JoinGroupResponse joinResponse, RequestFuture&lt;ByteBuffer&gt; future)</span> </span>&#123;</span><br><span class="line">    Errors error = joinResponse.error();</span><br><span class="line">    <span class="keyword">if</span> (error == Errors.NONE) &#123; <span class="comment">// 没有异常</span></span><br><span class="line">        log.debug(<span class="string">"Received successful JoinGroup response: &#123;&#125;"</span>, joinResponse);</span><br><span class="line">        sensors.joinSensor.record(response.requestLatencyMs());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (AbstractCoordinator.<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (state != MemberState.REBALANCING) &#123;</span><br><span class="line">                <span class="comment">// if the consumer was woken up before a rebalance completes, we may have already left</span></span><br><span class="line">                <span class="comment">// the group. In this case, we do not want to continue with the sync group.</span></span><br><span class="line">                future.raise(<span class="keyword">new</span> UnjoinedGroupException());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 记录id</span></span><br><span class="line">                AbstractCoordinator.<span class="keyword">this</span>.generation = <span class="keyword">new</span> Generation(joinResponse.data().generationId(),</span><br><span class="line">                        joinResponse.data().memberId(), joinResponse.data().protocolName());</span><br><span class="line">                <span class="comment">// 判断是否leader节点</span></span><br><span class="line">                <span class="comment">// 发送SyncGroupRequest</span></span><br><span class="line">                <span class="comment">// leader节点会直接分配好分区，将这个分配信息一起传给coordinator节点</span></span><br><span class="line">                <span class="keyword">if</span> (joinResponse.isLeader()) &#123;</span><br><span class="line">                    onJoinLeader(joinResponse).chain(future);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    onJoinFollower().chain(future);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (error == Errors.COORDINATOR_LOAD_IN_PROGRESS) &#123;</span><br><span class="line">        log.debug(<span class="string">"Attempt to join group rejected since coordinator &#123;&#125; is loading the group."</span>, coordinator());</span><br><span class="line">        <span class="comment">// backoff and retry</span></span><br><span class="line">        future.raise(error);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (error == Errors.UNKNOWN_MEMBER_ID) &#123;</span><br><span class="line">        <span class="comment">// reset the member id and retry immediately</span></span><br><span class="line">        resetGenerationOnResponseError(ApiKeys.JOIN_GROUP, error);</span><br><span class="line">        log.debug(<span class="string">"Attempt to join group failed due to unknown member id."</span>);</span><br><span class="line">        future.raise(error);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (error == Errors.COORDINATOR_NOT_AVAILABLE</span><br><span class="line">            || error == Errors.NOT_COORDINATOR) &#123;</span><br><span class="line">        <span class="comment">// re-discover the coordinator and retry with backoff</span></span><br><span class="line">        markCoordinatorUnknown();</span><br><span class="line">        log.debug(<span class="string">"Attempt to join group failed due to obsolete coordinator information: &#123;&#125;"</span>, error.message());</span><br><span class="line">        future.raise(error);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (error == Errors.FENCED_INSTANCE_ID) &#123;</span><br><span class="line">        log.error(<span class="string">"Received fatal exception: group.instance.id gets fenced"</span>);</span><br><span class="line">        future.raise(error);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (error == Errors.INCONSISTENT_GROUP_PROTOCOL</span><br><span class="line">            || error == Errors.INVALID_SESSION_TIMEOUT</span><br><span class="line">            || error == Errors.INVALID_GROUP_ID</span><br><span class="line">            || error == Errors.GROUP_AUTHORIZATION_FAILED</span><br><span class="line">            || error == Errors.GROUP_MAX_SIZE_REACHED) &#123;</span><br><span class="line">        <span class="comment">// log the error and re-throw the exception</span></span><br><span class="line">        log.error(<span class="string">"Attempt to join group failed due to fatal error: &#123;&#125;"</span>, error.message());</span><br><span class="line">        <span class="keyword">if</span> (error == Errors.GROUP_MAX_SIZE_REACHED) &#123;</span><br><span class="line">            future.raise(<span class="keyword">new</span> GroupMaxSizeReachedException(<span class="string">"Consumer group "</span> + rebalanceConfig.groupId +</span><br><span class="line">                    <span class="string">" already has the configured maximum number of members."</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (error == Errors.GROUP_AUTHORIZATION_FAILED) &#123;</span><br><span class="line">            future.raise(GroupAuthorizationException.forGroupId(rebalanceConfig.groupId));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            future.raise(error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (error == Errors.UNSUPPORTED_VERSION) &#123;</span><br><span class="line">        log.error(<span class="string">"Attempt to join group failed due to unsupported version error. Please unset field group.instance.id and retry"</span> +</span><br><span class="line">                <span class="string">"to see if the problem resolves"</span>);</span><br><span class="line">        future.raise(error);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (error == Errors.MEMBER_ID_REQUIRED) &#123;</span><br><span class="line">        <span class="comment">// Broker requires a concrete member id to be allowed to join the group. Update member id</span></span><br><span class="line">        <span class="comment">// and send another join group request in next cycle.</span></span><br><span class="line">        <span class="keyword">synchronized</span> (AbstractCoordinator.<span class="keyword">this</span>) &#123;</span><br><span class="line">            AbstractCoordinator.<span class="keyword">this</span>.generation = <span class="keyword">new</span> Generation(OffsetCommitRequest.DEFAULT_GENERATION_ID,</span><br><span class="line">                    joinResponse.data().memberId(), <span class="keyword">null</span>);</span><br><span class="line">            AbstractCoordinator.<span class="keyword">this</span>.resetStateAndRejoin();</span><br><span class="line">        &#125;</span><br><span class="line">        future.raise(error);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// unexpected error, throw the exception</span></span><br><span class="line">        log.error(<span class="string">"Attempt to join group failed due to unexpected error: &#123;&#125;"</span>, error.message());</span><br><span class="line">        future.raise(<span class="keyword">new</span> KafkaException(<span class="string">"Unexpected error in join group response: "</span> + error.message()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/hudeqi/articles/12568591.html" target="_blank" rel="noopener">KAFKA源码走读-COORDINATOR</a></p>
</div><div class="tags"><a href="/tags/网络/">网络</a><a href="/tags/kafka/">kafka</a><a href="/tags/消费者/">消费者</a><a href="/tags/rebalance/">rebalance</a><a href="/tags/coordinator/">coordinator</a></div><div class="post-nav"><a class="pre" href="/2020/05/07/kafka事务/">kafka：事务原理</a><a class="next" href="/2020/04/09/kafka生产者客户端发送逻辑简析/">kafka：生产者客户端发送逻辑简析</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="https://SvizzerChow.github.io"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Netty/">Netty</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Sentinel/">Sentinel</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/kafka/">kafka</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/redis/">redis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/sharding-jdbc/">sharding-jdbc</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/分布式/">分布式</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/并发/">并发</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据库/">数据库</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法/">算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/线程池/">线程池</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/网络/">网络</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/虚拟机/">虚拟机</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/源码解析/" style="font-size: 15px;">源码解析</a> <a href="/tags/BASE理论/" style="font-size: 15px;">BASE理论</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/并发/" style="font-size: 15px;">并发</a> <a href="/tags/JUC/" style="font-size: 15px;">JUC</a> <a href="/tags/虚拟机/" style="font-size: 15px;">虚拟机</a> <a href="/tags/JavaAgent/" style="font-size: 15px;">JavaAgent</a> <a href="/tags/集合/" style="font-size: 15px;">集合</a> <a href="/tags/可见性/" style="font-size: 15px;">可见性</a> <a href="/tags/内存模型/" style="font-size: 15px;">内存模型</a> <a href="/tags/MESI/" style="font-size: 15px;">MESI</a> <a href="/tags/volatile/" style="font-size: 15px;">volatile</a> <a href="/tags/MySQL/" style="font-size: 15px;">MySQL</a> <a href="/tags/网络/" style="font-size: 15px;">网络</a> <a href="/tags/Netty/" style="font-size: 15px;">Netty</a> <a href="/tags/channel/" style="font-size: 15px;">channel</a> <a href="/tags/ServerBootstrap/" style="font-size: 15px;">ServerBootstrap</a> <a href="/tags/NioEventLoop/" style="font-size: 15px;">NioEventLoop</a> <a href="/tags/启动/" style="font-size: 15px;">启动</a> <a href="/tags/线程模型/" style="font-size: 15px;">线程模型</a> <a href="/tags/读写事件/" style="font-size: 15px;">读写事件</a> <a href="/tags/http/" style="font-size: 15px;">http</a> <a href="/tags/沾包/" style="font-size: 15px;">沾包</a> <a href="/tags/拆包/" style="font-size: 15px;">拆包</a> <a href="/tags/内存/" style="font-size: 15px;">内存</a> <a href="/tags/NIO/" style="font-size: 15px;">NIO</a> <a href="/tags/redis/" style="font-size: 15px;">redis</a> <a href="/tags/NoSQL/" style="font-size: 15px;">NoSQL</a> <a href="/tags/限流/" style="font-size: 15px;">限流</a> <a href="/tags/降级/" style="font-size: 15px;">降级</a> <a href="/tags/熔断/" style="font-size: 15px;">熔断</a> <a href="/tags/Sentinel/" style="font-size: 15px;">Sentinel</a> <a href="/tags/CAP理论/" style="font-size: 15px;">CAP理论</a> <a href="/tags/TCP/" style="font-size: 15px;">TCP</a> <a href="/tags/kafka/" style="font-size: 15px;">kafka</a> <a href="/tags/事务/" style="font-size: 15px;">事务</a> <a href="/tags/锁/" style="font-size: 15px;">锁</a> <a href="/tags/原子性/" style="font-size: 15px;">原子性</a> <a href="/tags/long/" style="font-size: 15px;">long</a> <a href="/tags/double/" style="font-size: 15px;">double</a> <a href="/tags/消费者/" style="font-size: 15px;">消费者</a> <a href="/tags/rebalance/" style="font-size: 15px;">rebalance</a> <a href="/tags/coordinator/" style="font-size: 15px;">coordinator</a> <a href="/tags/sentinel/" style="font-size: 15px;">sentinel</a> <a href="/tags/zookeeper/" style="font-size: 15px;">zookeeper</a> <a href="/tags/生产者/" style="font-size: 15px;">生产者</a> <a href="/tags/分布式锁/" style="font-size: 15px;">分布式锁</a> <a href="/tags/数据库/" style="font-size: 15px;">数据库</a> <a href="/tags/分库分表/" style="font-size: 15px;">分库分表</a> <a href="/tags/io/" style="font-size: 15px;">io</a> <a href="/tags/同步/" style="font-size: 15px;">同步</a> <a href="/tags/异步/" style="font-size: 15px;">异步</a> <a href="/tags/线程池/" style="font-size: 15px;">线程池</a> <a href="/tags/Excutors/" style="font-size: 15px;">Excutors</a> <a href="/tags/多线程/" style="font-size: 15px;">多线程</a> <a href="/tags/FutureTask/" style="font-size: 15px;">FutureTask</a> <a href="/tags/AbstractExecutorService/" style="font-size: 15px;">AbstractExecutorService</a> <a href="/tags/ThreadPoolExecutor/" style="font-size: 15px;">ThreadPoolExecutor</a> <a href="/tags/缓存/" style="font-size: 15px;">缓存</a> <a href="/tags/缓存行/" style="font-size: 15px;">缓存行</a> <a href="/tags/轮询/" style="font-size: 15px;">轮询</a> <a href="/tags/算法/" style="font-size: 15px;">算法</a> <a href="/tags/ScheduledThreadPoolExecutor/" style="font-size: 15px;">ScheduledThreadPoolExecutor</a> <a href="/tags/Spring/" style="font-size: 15px;">Spring</a> <a href="/tags/sharding-jdbc/" style="font-size: 15px;">sharding-jdbc</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/05/26/lock 与 synchronized的区别/">lock 与 synchronized的区别</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/26/CountDownLatch和CyclicBarrier的区别/">JUC:CountDownLatch和CyclicBarrier的区别</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/07/kafka事务/">kafka：事务原理</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/15/kafka消费者rebalance简析/">kafka：消费者rebalance简析</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/09/kafka生产者客户端发送逻辑简析/">kafka：生产者客户端发送逻辑简析</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/19/Netty之旅30对象池Recycler/">Netty解析二十八：Netty对象池Recycler</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/18/Netty之旅29PooledByteBufAllocator/">Netty解析二十七：Netty内存分配PooledByteBufAllocator</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/18/Netty之旅28PooledByteBuf/">Netty解析二十六：Netty内存分配PooledByteBuf</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/16/Netty之旅27PoolArena/">Netty解析二十五：Netty内存分配PoolArena</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/13/Netty之旅26PoolChunkList/">Netty解析二十四：Netty内存分配PoolChunkList</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2017-2020 <a href="/." rel="nofollow">SvizzerChow's Blog.</a><a rel="nofollow" target="_blank" href="http://www.beian.miit.gov.cn"> 浙ICP备18053179号</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>