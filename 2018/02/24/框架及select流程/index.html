<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="我的个人博客"><title>分库分表sharding-jdbc源码解析 | SvizzerChow's Blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">分库分表sharding-jdbc源码解析</h1><a id="logo" href="/.">SvizzerChow's Blog</a><p class="description">Leaning</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">分库分表sharding-jdbc源码解析</h1><div class="post-meta">Feb 24, 2018<span> | </span><span class="category"><a href="/categories/sharding-jdbc/">sharding-jdbc</a></span></div><div class="post-content"><p>[TOC]</p>
<h1 id="sharding-jdbc架构"><a href="#sharding-jdbc架构" class="headerlink" title="sharding-jdbc架构"></a>sharding-jdbc架构</h1><p>架构图<br><img src="http://shardingsphere.io/document/legacy/1.x/cn/img/architecture.png" alt="image"></p>
<h1 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h1><p><strong>LogicTable</strong><br>数据分片的逻辑表，对于水平拆分的数据库(表)，同一类表的总称。例：订单数据根据主键尾数拆分为10张表,分别是t_order_0到t_order_9，他们的逻辑表名为t_order。</p>
<p><strong>ActualTable</strong><br>在分片的数据库中真实存在的物理表。即上个示例中的t_order_0到t_order_9。</p>
<p><strong>DataNode</strong><br>数据分片的最小单元。由数据源名称和数据表组成，例：ds_1.t_order_0。配置时默认各个分片数据库的表结构均相同，直接配置逻辑表和真实表对应关系即可。如果各数据库的表结果不同，可使用ds.actual_table配置。<br><a id="more"></a></p>
<p><strong>BindingTable</strong><br>指在任何场景下分片规则均一致的主表和子表。例：订单表和订单项表，均按照订单ID分片，则此两张表互为BindingTable关系。BindingTable关系的多表关联查询不会出现笛卡尔积关联，关联查询效率将大大提升。举例说明，如果SQL为：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> i.* <span class="keyword">FROM</span> t_order o <span class="keyword">JOIN</span> t_order_item i <span class="keyword">ON</span> o.order_id=i.order_id <span class="keyword">WHERE</span> o.order_id <span class="keyword">in</span> (<span class="number">10</span>, <span class="number">11</span>);</span><br></pre></td></tr></table></figure></p>
<pre><code>在不配置绑定表关系时，假设分片键order_id将数值10路由至第0片，将数值11路由至第1片，那么路由后的SQL应该为4条，它们呈现为笛卡尔积：
</code></pre><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> i.* <span class="keyword">FROM</span> t_order_0 o <span class="keyword">JOIN</span> t_order_item_0 i <span class="keyword">ON</span> o.order_id=i.order_id <span class="keyword">WHERE</span> o.order_id <span class="keyword">in</span> (<span class="number">10</span>, <span class="number">11</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> i.* <span class="keyword">FROM</span> t_order_0 o <span class="keyword">JOIN</span> t_order_item_1 i <span class="keyword">ON</span> o.order_id=i.order_id <span class="keyword">WHERE</span> o.order_id <span class="keyword">in</span> (<span class="number">10</span>, <span class="number">11</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> i.* <span class="keyword">FROM</span> t_order_1 o <span class="keyword">JOIN</span> t_order_item_0 i <span class="keyword">ON</span> o.order_id=i.order_id <span class="keyword">WHERE</span> o.order_id <span class="keyword">in</span> (<span class="number">10</span>, <span class="number">11</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> i.* <span class="keyword">FROM</span> t_order_1 o <span class="keyword">JOIN</span> t_order_item_1 i <span class="keyword">ON</span> o.order_id=i.order_id <span class="keyword">WHERE</span> o.order_id <span class="keyword">in</span> (<span class="number">10</span>, <span class="number">11</span>);</span><br></pre></td></tr></table></figure>
<pre><code>在配置绑定表关系后，路由的SQL应该为2条：
</code></pre><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> i.* <span class="keyword">FROM</span> t_order_0 o <span class="keyword">JOIN</span> t_order_item_0 i <span class="keyword">ON</span> o.order_id=i.order_id <span class="keyword">WHERE</span> o.order_id <span class="keyword">in</span> (<span class="number">10</span>, <span class="number">11</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> i.* <span class="keyword">FROM</span> t_order_1 o <span class="keyword">JOIN</span> t_order_item_1 i <span class="keyword">ON</span> o.order_id=i.order_id <span class="keyword">WHERE</span> o.order_id <span class="keyword">in</span> (<span class="number">10</span>, <span class="number">11</span>);</span><br></pre></td></tr></table></figure>
<pre><code>其中t_order在FROM的最左侧，Sharding-Sphere将会以它作为整个绑定表的主表。所有路由计算将会只使用主表的策略，那么t_order_item表的分片计算将会使用t_order的条件。故绑定表之间的分区键要完全相同。
</code></pre><p><strong>ShardingColumn</strong><br>分片字段。用于将数据库(表)水平拆分的关键字段。例：订单表订单ID分片尾数取模分片，则订单ID为分片字段。SQL中如果无分片字段，将执行全路由，性能较差。Sharding-JDBC支持多分片字段。</p>
<p><strong>ShardingAlgorithm</strong><br>分片算法。Sharding-JDBC通过分片算法将数据分片，支持通过等号、BETWEEN和IN分片。分片算法目前需要业务方开发者自行实现，可实现的灵活度非常高。未来Sharding-JDBC也将会实现常用分片算法，如range，hash和tag等。</p>
<p><strong>SQL Hint</strong><br>对于分片字段非SQL决定，而由其他外置条件决定的场景，可使用SQL Hint灵活的注入分片字段。例：内部系统，按照员工登录ID分库，而数据库中并无此字段。SQL Hint支持通过ThreadLocal和SQL注释(待实现)两种方式使用。</p>
<p><strong>Config Map</strong><br>通过ConfigMap可以配置分库分表或读写分离数据源的元数据，可通过调用ConfigMapContext.getInstance()获取ConfigMap中的shardingConfig和masterSlaveConfig数据。例：如果机器权重不同则流量可能不同，可通过ConfigMap配置机器权重元数据。</p>
<p><strong>LogicIndex</strong><br>数据分片的逻辑索引名称，DDL语句中水平拆分的表，同一类表的总称。例：订单数据根据主键尾数拆分为10张表,分别是t_order_0到t_order_9，他们的逻辑表名为t_order，对于DROP INDEX t_order_index语句， 需在TableRule中配置逻辑索引t_order_index。</p>
<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>配置sharding-jdbc<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span>(name = <span class="string">"shardingDataSource"</span>)</span><br><span class="line"><span class="function">DataSource <span class="title">getShardingDataSource</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    </span><br><span class="line">    Map&lt;String, DataSource&gt; dataSourceMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 将dataSource纳入shardingDataSource管理</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    dataSourceMap.put(<span class="string">"souche_bilocation"</span>, dataSource);</span><br><span class="line">    ShardingRuleConfiguration shardingRuleConfig = <span class="keyword">new</span> ShardingRuleConfiguration();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 定义分表算法</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    TableRuleConfiguration tableRuleConfig = <span class="keyword">new</span> TableRuleConfiguration();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 设置逻辑表（逻辑表就是我们写在SQL中的表名）</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    tableRuleConfig.setLogicTable(<span class="string">"customer_track"</span>);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 设置实际表（最后我们数据落地的表，这里就是cutomer_track_0,customer_track_1）</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    tableRuleConfig.setActualDataNodes(<span class="string">"souche_bilocation.customer_track_$&#123;0..1&#125;"</span>);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 设置分表配置，这里分表字段是user_id，算法就是实现的hashcode取余算法</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    tableRuleConfig.setTableShardingStrategyConfig(</span><br><span class="line">        <span class="keyword">new</span> StandardShardingStrategyConfiguration(<span class="string">"user_id"</span>, StringModeShardingAlgorithm.class.getName()));</span><br><span class="line">    shardingRuleConfig.getTableRuleConfigs().add(tableRuleConfig);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ShardingDataSourceFactory.createDataSource(dataSourceMap, shardingRuleConfig,<span class="keyword">new</span> ConcurrentHashMap&lt;String, Object&gt;(), <span class="keyword">new</span> Properties());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h1><h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><p><strong>本文内容基于以下前提：</strong></p>
<ol>
<li><p>shardingjdbc版本为2.0.3;</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.shardingjdbc<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sharding-jdbc-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>流程以<code>preparedStatement.executeQuery()</code>方式执行;</p>
<blockquote>
<p><code>Statement.executeQuery()</code>依赖的是StatementRoutingEngine;<br><br><code>preparedStatement.executeQuery()</code>依赖的是PreparedStatementRoutingEngine;<br><br>StatementRoutingEngine和PreparedStatementRoutingEngine内部都是依赖ParsingSQLRouter进行解析和路由的，所以整体的执行过程是一致的。</p>
</blockquote>
</li>
</ol>
<h2 id="sql解析"><a href="#sql解析" class="headerlink" title="sql解析"></a>sql解析</h2><h3 id="添加字段"><a href="#添加字段" class="headerlink" title="添加字段"></a>添加字段</h3><p>appendDerivedColumns()和appendDerivedOrderBy()方法分别处理avg函数字段和排序字段的添加。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractSelectParser</span> <span class="keyword">implements</span> <span class="title">SQLParser</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> SelectStatement <span class="title">parse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SelectStatement result = parseInternal();</span><br><span class="line">        <span class="keyword">if</span> (result.containsSubQuery()) &#123;</span><br><span class="line">            result = result.mergeSubQueryStatement();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// TODO move to rewrite</span></span><br><span class="line">        appendDerivedColumns(result);</span><br><span class="line">        appendDerivedOrderBy(result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="avg函数添加字段及group字段补充-appendDerivedColumns"><a href="#avg函数添加字段及group字段补充-appendDerivedColumns" class="headerlink" title="avg函数添加字段及group字段补充(appendDerivedColumns)"></a>avg函数添加字段及group字段补充(appendDerivedColumns)</h4><p>sql中有avg()函数时，想要正确的从几个库表中获取数据，几个avg()求和作平均得到的结果是不对的，必须采用sum(field)/count(field)，所以要将原来的<code>select avg(field) from</code>改写为<code>select sum(field), count(field)</code></p>
<p>这个阶段发生在MySQLSelectParser.parse()(实际是AbstractSelectParser.parse())。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">appendDerivedColumns</span><span class="params">(<span class="keyword">final</span> SelectStatement selectStatement)</span> </span>&#123;</span><br><span class="line">    ItemsToken itemsToken = <span class="keyword">new</span> ItemsToken(selectStatement.getSelectListLastPosition());</span><br><span class="line">    <span class="comment">// avg(field)函数添加sum(field)和count(field)</span></span><br><span class="line">    appendAvgDerivedColumns(itemsToken, selectStatement);</span><br><span class="line">    <span class="comment">//order by字段/group by字段如果不在select列表中就添加，保证内存排序可行</span></span><br><span class="line">    appendDerivedOrderColumns(itemsToken, selectStatement.getOrderByItems(), ORDER_BY_DERIVED_ALIAS, selectStatement);</span><br><span class="line">    appendDerivedOrderColumns(itemsToken, selectStatement.getGroupByItems(), GROUP_BY_DERIVED_ALIAS, selectStatement);</span><br><span class="line">    <span class="comment">// 下面把新加的字段也加入SqlToken，SqlToken是用于生成最后执行的sql，SQLRewriteEngine.rewrite()</span></span><br><span class="line">    <span class="keyword">if</span> (!itemsToken.getItems().isEmpty()) &#123;</span><br><span class="line">        selectStatement.getSqlTokens().add(itemsToken);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">appendAvgDerivedColumns</span><span class="params">(<span class="keyword">final</span> ItemsToken itemsToken, <span class="keyword">final</span> SelectStatement selectStatement)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 偏移量防止别名冲突</span></span><br><span class="line">    <span class="keyword">int</span> derivedColumnOffset = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (SelectItem each : selectStatement.getItems()) &#123;</span><br><span class="line">        <span class="comment">// 找到avg函数</span></span><br><span class="line">        <span class="keyword">if</span> (!(each <span class="keyword">instanceof</span> AggregationSelectItem) || AggregationType.AVG != ((AggregationSelectItem) each).getType()) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        AggregationSelectItem avgItem = (AggregationSelectItem) each;</span><br><span class="line">        <span class="comment">// count的别名</span></span><br><span class="line">        String countAlias = String.format(DERIVED_COUNT_ALIAS, derivedColumnOffset);</span><br><span class="line">        <span class="comment">// 生成Item</span></span><br><span class="line">        AggregationSelectItem countItem = <span class="keyword">new</span> AggregationSelectItem(AggregationType.COUNT, avgItem.getInnerExpression(), Optional.of(countAlias));</span><br><span class="line">        <span class="comment">// sum的别名</span></span><br><span class="line">        String sumAlias = String.format(DERIVED_SUM_ALIAS, derivedColumnOffset);</span><br><span class="line">        <span class="comment">// 生成Item</span></span><br><span class="line">        AggregationSelectItem sumItem = <span class="keyword">new</span> AggregationSelectItem(AggregationType.SUM, avgItem.getInnerExpression(), Optional.of(sumAlias));</span><br><span class="line">        <span class="comment">// count和sum加到avg的derivedAggregationSelectItems</span></span><br><span class="line">        avgItem.getDerivedAggregationSelectItems().add(countItem);</span><br><span class="line">        avgItem.getDerivedAggregationSelectItems().add(sumItem);</span><br><span class="line">        <span class="comment">// TODO replace avg to constant, avoid calculate useless avg</span></span><br><span class="line">        <span class="comment">// 这里加到itemsToken用于后续SQL改写</span></span><br><span class="line">        itemsToken.getItems().add(countItem.getExpression() + <span class="string">" AS "</span> + countAlias + <span class="string">" "</span>);</span><br><span class="line">        itemsToken.getItems().add(sumItem.getExpression() + <span class="string">" AS "</span> + sumAlias + <span class="string">" "</span>);</span><br><span class="line">        derivedColumnOffset++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// order by字段/group by字段如果不在select列表中就添加，保证内存排序可行</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">appendDerivedOrderColumns</span><span class="params">(<span class="keyword">final</span> ItemsToken itemsToken, <span class="keyword">final</span> List&lt;OrderItem&gt; orderItems, <span class="keyword">final</span> String aliasPattern, <span class="keyword">final</span> SelectStatement selectStatement)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> derivedColumnOffset = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (OrderItem each : orderItems) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isContainsItem(each, selectStatement)) &#123;</span><br><span class="line">            String alias = String.format(aliasPattern, derivedColumnOffset++);</span><br><span class="line">            each.setAlias(Optional.of(alias));</span><br><span class="line">            itemsToken.getItems().add(each.getQualifiedName().get() + <span class="string">" AS "</span> + alias + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="有group无order添加排序-appendDerivedOrderBy"><a href="#有group无order添加排序-appendDerivedOrderBy" class="headerlink" title="有group无order添加排序(appendDerivedOrderBy)"></a>有group无order添加排序(appendDerivedOrderBy)</h4><p>如果有group by但是没有order by，那就加上group by的字段为排序字段。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">appendDerivedOrderBy</span><span class="params">(<span class="keyword">final</span> SelectStatement selectStatement)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!selectStatement.getGroupByItems().isEmpty() &amp;&amp; selectStatement.getOrderByItems().isEmpty()) &#123;</span><br><span class="line">        selectStatement.getOrderByItems().addAll(selectStatement.getGroupByItems());</span><br><span class="line">        selectStatement.getSqlTokens().add(<span class="keyword">new</span> OrderByToken(selectStatement.getGroupByLastPosition()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><p><strong>这里的路由是指根据逻辑表名找到实际数据库和物理表名的过程。</strong></p>
<p>路由发生在 ParsingSQLRouter.route() -&gt; RoutingEngine.route()。</p>
<p>ParsingSQLRouter.route()中根据sql是DDL/无表/单表/多表，使用不同的RoutingEngine。<br><img src="https://i.loli.net/2018/11/19/5bf2ae3c4af49.png" alt="路由.png"><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> RoutingResult <span class="title">route</span><span class="params">(<span class="keyword">final</span> List&lt;Object&gt; parameters, <span class="keyword">final</span> SQLStatement sqlStatement)</span> </span>&#123;</span><br><span class="line">    Collection&lt;String&gt; tableNames = sqlStatement.getTables().getTableNames();</span><br><span class="line">    RoutingEngine routingEngine;</span><br><span class="line">    <span class="keyword">if</span> (sqlStatement <span class="keyword">instanceof</span> DDLStatement) &#123;</span><br><span class="line">        routingEngine = <span class="keyword">new</span> DDLRoutingEngine(shardingRule, parameters, (DDLStatement) sqlStatement); </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tableNames.isEmpty()) &#123;</span><br><span class="line">        routingEngine = <span class="keyword">new</span> DatabaseAllRoutingEngine(shardingRule.getDataSourceMap());</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">1</span> == tableNames.size() || shardingRule.isAllBindingTables(tableNames) || shardingRule.isAllInDefaultDataSource(tableNames)) &#123;</span><br><span class="line">        routingEngine = <span class="keyword">new</span> SimpleRoutingEngine(shardingRule, parameters, tableNames.iterator().next(), sqlStatement);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// TODO config for cartesian set</span></span><br><span class="line">        routingEngine = <span class="keyword">new</span> ComplexRoutingEngine(shardingRule, parameters, tableNames, sqlStatement);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> routingEngine.route();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>路由结果(RoutingResult)会在ParsingSQLRouter.route()中用于获取TableUnit。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SQLRouteResult <span class="title">route</span><span class="params">(<span class="keyword">final</span> String logicSQL, <span class="keyword">final</span> List&lt;Object&gt; parameters, <span class="keyword">final</span> SQLStatement sqlStatement)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...省略无关代码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// route()执行了上文的路由过程，获得CartesianRoutingResult</span></span><br><span class="line">    RoutingResult routingResult = route(parameters, sqlStatement);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 这里CartesianRoutingResult单独处理</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    <span class="keyword">if</span> (routingResult <span class="keyword">instanceof</span> CartesianRoutingResult) &#123;</span><br><span class="line">        <span class="keyword">for</span> (CartesianDataSource cartesianDataSource : ((CartesianRoutingResult) routingResult).getRoutingDataSources()) &#123;</span><br><span class="line">            <span class="comment">// cartesianTableReference中包含了一个db中的所有实际表名</span></span><br><span class="line">            <span class="keyword">for</span> (CartesianTableReference cartesianTableReference : cartesianDataSource.getRoutingTableReferences()) &#123;</span><br><span class="line">                result.getExecutionUnits().add(<span class="keyword">new</span> SQLExecutionUnit(cartesianDataSource.getDataSource(), rewriteEngine.generateSQL(cartesianTableReference, sqlBuilder)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 通用处理</span></span><br><span class="line">        <span class="keyword">for</span> (TableUnit each : routingResult.getTableUnits().getTableUnits()) &#123;</span><br><span class="line">            result.getExecutionUnits().add(<span class="keyword">new</span> SQLExecutionUnit(each.getDataSourceName(), rewriteEngine.generateSQL(each, sqlBuilder)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (showSQL) &#123;</span><br><span class="line">        SQLLogger.logSQL(logicSQL, sqlStatement, result.getExecutionUnits(), parameters);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="单表路由-SimpleRoutingEngine"><a href="#单表路由-SimpleRoutingEngine" class="headerlink" title="单表路由(SimpleRoutingEngine)"></a>单表路由(SimpleRoutingEngine)</h3><p>SimpleRoutingEngine是所有路由的核心，使用配置的TableRule进行路由。</p>
<p><img src="https://i.loli.net/2018/11/19/5bf286d0d5f99.png" alt></p>
<p>路由解析：</p>
<ol>
<li>获取db和table路由字段值，如果是强制路由则从HintManagerHolder获取；</li>
<li>根据StandardShardingStrategyConfiguration配置的ShardingStrategy进行db路由；</li>
<li>根据StandardShardingStrategyConfiguration配置的ShardingStrategy进行table路由；</li>
<li>路由结果封装。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleRoutingEngine</span> <span class="keyword">implements</span> <span class="title">RoutingEngine</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ShardingRule shardingRule;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Object&gt; parameters;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String logicTableName;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SQLStatement sqlStatement;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RoutingResult <span class="title">route</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 根据逻辑表名获取配置的规则</span></span><br><span class="line">        TableRule tableRule = shardingRule.getTableRule(logicTableName);</span><br><span class="line">        <span class="comment">// 获取配置的路由字段值</span></span><br><span class="line">        List&lt;ShardingValue&gt; databaseShardingValues = getDatabaseShardingValues(tableRule);</span><br><span class="line">        <span class="comment">// 获取配置的路由字段值</span></span><br><span class="line">        List&lt;ShardingValue&gt; tableShardingValues = getTableShardingValues(tableRule);</span><br><span class="line">        <span class="comment">// 根据配置(ShardingStrategy)进行db路由</span></span><br><span class="line">        Collection&lt;String&gt; routedDataSources = routeDataSources(tableRule, databaseShardingValues);</span><br><span class="line">        Collection&lt;DataNode&gt; routedDataNodes = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String each : routedDataSources) &#123;</span><br><span class="line">            <span class="comment">// 根据路由字段值进行table路由</span></span><br><span class="line">            routedDataNodes.addAll(routeTables(tableRule, each, tableShardingValues));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> generateRoutingResult(routedDataNodes);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> List&lt;ShardingValue&gt; <span class="title">getDatabaseShardingValues</span><span class="params">(<span class="keyword">final</span> TableRule tableRule)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// strategy 配置的规则</span></span><br><span class="line">        ShardingStrategy strategy = shardingRule.getDatabaseShardingStrategy(tableRule);</span><br><span class="line">        <span class="comment">// isUseShardingHint 先判断是否使用强制路由</span></span><br><span class="line">        <span class="keyword">return</span> HintManagerHolder.isUseShardingHint() ? getDatabaseShardingValuesFromHint(strategy.getShardingColumns()) : getShardingValues(strategy.getShardingColumns());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> List&lt;ShardingValue&gt; <span class="title">getTableShardingValues</span><span class="params">(<span class="keyword">final</span> TableRule tableRule)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// strategy 配置的规则</span></span><br><span class="line">        ShardingStrategy strategy = shardingRule.getTableShardingStrategy(tableRule);</span><br><span class="line">        <span class="comment">// isUseShardingHint 先判断是否使用强制路由</span></span><br><span class="line">        <span class="keyword">return</span> HintManagerHolder.isUseShardingHint() ? getTableShardingValuesFromHint(strategy.getShardingColumns()) : getShardingValues(strategy.getShardingColumns());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> List&lt;ShardingValue&gt; <span class="title">getDatabaseShardingValuesFromHint</span><span class="params">(<span class="keyword">final</span> Collection&lt;String&gt; shardingColumns)</span> </span>&#123;</span><br><span class="line">        List&lt;ShardingValue&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;(shardingColumns.size());</span><br><span class="line">        <span class="keyword">for</span> (String each : shardingColumns) &#123;</span><br><span class="line">            Optional&lt;ShardingValue&gt; shardingValue = HintManagerHolder.getDatabaseShardingValue(<span class="keyword">new</span> ShardingKey(logicTableName, each));</span><br><span class="line">            <span class="keyword">if</span> (shardingValue.isPresent()) &#123;</span><br><span class="line">                result.add(shardingValue.get());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> List&lt;ShardingValue&gt; <span class="title">getTableShardingValuesFromHint</span><span class="params">(<span class="keyword">final</span> Collection&lt;String&gt; shardingColumns)</span> </span>&#123;</span><br><span class="line">        List&lt;ShardingValue&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;(shardingColumns.size());</span><br><span class="line">        <span class="keyword">for</span> (String each : shardingColumns) &#123;</span><br><span class="line">            Optional&lt;ShardingValue&gt; shardingValue = HintManagerHolder.getTableShardingValue(<span class="keyword">new</span> ShardingKey(logicTableName, each));</span><br><span class="line">            <span class="keyword">if</span> (shardingValue.isPresent()) &#123;</span><br><span class="line">                result.add(shardingValue.get());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> List&lt;ShardingValue&gt; <span class="title">getShardingValues</span><span class="params">(<span class="keyword">final</span> Collection&lt;String&gt; shardingColumns)</span> </span>&#123;</span><br><span class="line">        List&lt;ShardingValue&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;(shardingColumns.size());</span><br><span class="line">        <span class="keyword">for</span> (String each : shardingColumns) &#123;</span><br><span class="line">            Optional&lt;Condition&gt; condition = sqlStatement.getConditions().find(<span class="keyword">new</span> Column(each, logicTableName));</span><br><span class="line">            <span class="keyword">if</span> (condition.isPresent()) &#123;</span><br><span class="line">                result.add(condition.get().getShardingValue(parameters));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> Collection&lt;String&gt; <span class="title">routeDataSources</span><span class="params">(<span class="keyword">final</span> TableRule tableRule, <span class="keyword">final</span> List&lt;ShardingValue&gt; databaseShardingValues)</span> </span>&#123;</span><br><span class="line">        Collection&lt;String&gt; availableTargetDatabases = tableRule.getActualDatasourceNames();</span><br><span class="line">        <span class="keyword">if</span> (databaseShardingValues.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> availableTargetDatabases;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// doSharding 进行路由判断</span></span><br><span class="line">        Collection&lt;String&gt; result = shardingRule.getDatabaseShardingStrategy(tableRule).doSharding(availableTargetDatabases, databaseShardingValues);</span><br><span class="line">        Preconditions.checkState(!result.isEmpty(), <span class="string">"no database route info"</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> Collection&lt;DataNode&gt; <span class="title">routeTables</span><span class="params">(<span class="keyword">final</span> TableRule tableRule, <span class="keyword">final</span> String routedDataSource, <span class="keyword">final</span> List&lt;ShardingValue&gt; tableShardingValues)</span> </span>&#123;</span><br><span class="line">        Collection&lt;String&gt; availableTargetTables = tableRule.getActualTableNames(routedDataSource);</span><br><span class="line">        <span class="comment">// doSharding 进行路由判断</span></span><br><span class="line">        Collection&lt;String&gt; routedTables = tableShardingValues.isEmpty() ? availableTargetTables</span><br><span class="line">                : shardingRule.getTableShardingStrategy(tableRule).doSharding(availableTargetTables, tableShardingValues);</span><br><span class="line">        Preconditions.checkState(!routedTables.isEmpty(), <span class="string">"no table route info"</span>);</span><br><span class="line">        Collection&lt;DataNode&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String each : routedTables) &#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> DataNode(routedDataSource, each));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 封装RoutingResult</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> RoutingResult <span class="title">generateRoutingResult</span><span class="params">(<span class="keyword">final</span> Collection&lt;DataNode&gt; routedDataNodes)</span> </span>&#123;</span><br><span class="line">        RoutingResult result = <span class="keyword">new</span> RoutingResult();</span><br><span class="line">        <span class="keyword">for</span> (DataNode each : routedDataNodes) &#123;</span><br><span class="line">            result.getTableUnits().getTableUnits().add(<span class="keyword">new</span> TableUnit(each.getDataSourceName(), logicTableName, each.getTableName()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="DDL路由-DDLRoutingEngine"><a href="#DDL路由-DDLRoutingEngine" class="headerlink" title="DDL路由(DDLRoutingEngine)"></a>DDL路由(DDLRoutingEngine)</h3><p>DDL路由实际使用的是SimpleRoutingEngine，和单表路由一致，详见单表路由。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DDLRoutingEngine</span> <span class="keyword">implements</span> <span class="title">RoutingEngine</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ShardingRule shardingRule;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Object&gt; parameters;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DDLStatement ddlStatement;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RoutingResult <span class="title">route</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用SimpleRoutingEngine</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SimpleRoutingEngine(shardingRule, parameters, getLogicTableName(), ddlStatement).route();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getLogicTableName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ddlStatement.getTables().isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> shardingRule.getLogicTableName(getIndexToken().getIndexName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ddlStatement.getTables().getSingleTableName();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> IndexToken <span class="title">getIndexToken</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Preconditions.checkState(<span class="number">1</span> == ddlStatement.getSqlTokens().size());</span><br><span class="line">        <span class="keyword">return</span> (IndexToken) ddlStatement.getSqlTokens().get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="无表路由-DatabaseAllRoutingEngine"><a href="#无表路由-DatabaseAllRoutingEngine" class="headerlink" title="无表路由(DatabaseAllRoutingEngine)"></a>无表路由(DatabaseAllRoutingEngine)</h3><p>无表路由返回值封装了空表<code>new TableUnit(each, &quot;&quot;, &quot;&quot;)</code>，其中each代表各个db的datasource。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DatabaseAllRoutingEngine</span> <span class="keyword">implements</span> <span class="title">RoutingEngine</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, DataSource&gt; dataSourceMap;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RoutingResult <span class="title">route</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        RoutingResult result = <span class="keyword">new</span> RoutingResult();</span><br><span class="line">        <span class="keyword">for</span> (String each : dataSourceMap.keySet()) &#123;</span><br><span class="line">            result.getTableUnits().getTableUnits().add(<span class="keyword">new</span> TableUnit(each, <span class="string">""</span>, <span class="string">""</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="多表路由-ComplexRoutingEngine"><a href="#多表路由-ComplexRoutingEngine" class="headerlink" title="多表路由(ComplexRoutingEngine)"></a>多表路由(ComplexRoutingEngine)</h3><h4 id="绑定表"><a href="#绑定表" class="headerlink" title="绑定表"></a>绑定表</h4><p><a href="#核心概念">绑定表</a></p>
<h5 id="配置绑定表"><a href="#配置绑定表" class="headerlink" title="配置绑定表"></a>配置绑定表</h5><p>ShardingDataSource配置shardingRuleConfig.setBindingTableGroups()即可绑定表。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span>(name = <span class="string">"shardingDataSource"</span>)</span><br><span class="line">	<span class="function">DataSource <span class="title">getShardingDataSource</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">		Map&lt;String, DataSource&gt; dataSourceMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">		dataSourceMap.put(<span class="string">"souche_bilocation_0"</span>, dataSource);</span><br><span class="line">        dataSourceMap.put(<span class="string">"souche_bilocation_1"</span>, dataSource);</span><br><span class="line">		ShardingRuleConfiguration shardingRuleConfig = <span class="keyword">new</span> ShardingRuleConfiguration();</span><br><span class="line"></span><br><span class="line">		shardingRuleConfig.setDefaultDatabaseShardingStrategyConfig(<span class="keyword">new</span> StandardShardingStrategyConfiguration(<span class="string">"id"</span>, StringModeShardingAlgorithm.class.getName()));</span><br><span class="line"></span><br><span class="line">		TableRuleConfiguration tableRuleConfig = <span class="keyword">new</span> TableRuleConfiguration();</span><br><span class="line">		tableRuleConfig.setLogicTable(<span class="string">"customer_track"</span>);</span><br><span class="line">		tableRuleConfig.setActualDataNodes(<span class="string">"souche_bilocation_$&#123;0..1&#125;.customer_track_$&#123;0..1&#125;"</span>);</span><br><span class="line">		tableRuleConfig.setTableShardingStrategyConfig(<span class="keyword">new</span> StandardShardingStrategyConfiguration(<span class="string">"id"</span>, StringModeShardingAlgorithm.class.getName()));</span><br><span class="line">		shardingRuleConfig.getTableRuleConfigs().add(tableRuleConfig);</span><br><span class="line"></span><br><span class="line">		TableRuleConfiguration customer_track_detail = <span class="keyword">new</span> TableRuleConfiguration();</span><br><span class="line">        customer_track_detail.setLogicTable(<span class="string">"customer_track_detail"</span>);</span><br><span class="line">        customer_track_detail.setActualDataNodes(<span class="string">"souche_bilocation_$&#123;0..1&#125;.customer_track_detail_$&#123;0..1&#125;"</span>);</span><br><span class="line">        customer_track_detail.setTableShardingStrategyConfig(<span class="keyword">new</span> StandardShardingStrategyConfiguration(<span class="string">"track_id"</span>, StringModeShardingAlgorithm.class.getName()));</span><br><span class="line">        shardingRuleConfig.getTableRuleConfigs().add(customer_track_detail);</span><br><span class="line">        <span class="comment">// 绑定表</span></span><br><span class="line">        shardingRuleConfig.setBindingTableGroups(Arrays.asList(<span class="string">"customer_track,customer_track_detail"</span>));</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> ShardingDataSourceFactory.createDataSource(dataSourceMap, shardingRuleConfig,<span class="keyword">new</span> ConcurrentHashMap&lt;String, Object&gt;(), <span class="keyword">new</span> Properties());</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>在ShardingRule构造器中会将bindingTableGroups转换成BindingTableRules。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ShardingRule</span><span class="params">(<span class="keyword">final</span> Map&lt;String, DataSource&gt; dataSourceMap, <span class="keyword">final</span> String defaultDataSourceName, <span class="keyword">final</span> Collection&lt;TableRule&gt; tableRules, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> Collection&lt;String&gt; bindingTableGroups, <span class="keyword">final</span> ShardingStrategy defaultDatabaseShardingStrategy, </span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> ShardingStrategy defaultTableShardingStrategy, <span class="keyword">final</span> KeyGenerator defaultKeyGenerator)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ... 省略其他</span></span><br><span class="line">    <span class="keyword">for</span> (String group : bindingTableGroups) &#123;</span><br><span class="line">        List&lt;TableRule&gt; tableRulesForBinding = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 以,分割</span></span><br><span class="line">        <span class="keyword">for</span> (String logicTableNameForBindingTable : StringUtil.splitWithComma(group)) &#123;</span><br><span class="line">            tableRulesForBinding.add(getTableRule(logicTableNameForBindingTable));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 绑定表的rule存在BindingTableRule中</span></span><br><span class="line">        <span class="keyword">this</span>.bindingTableRules.add(<span class="keyword">new</span> BindingTableRule(tableRulesForBinding));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ... 省略其他</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="BindingTableRule"><a href="#BindingTableRule" class="headerlink" title="BindingTableRule"></a>BindingTableRule</h5><p>BindingTableRule中保存了绑定表的TableRule集合。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">BindingTableRule</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;TableRule&gt; tableRules;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Adjust contains this logic table in this rule.</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> logicTableName logic table name</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> contains this logic table or not</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasLogicTable</span><span class="params">(<span class="keyword">final</span> String logicTableName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (TableRule each : tableRules) &#123;</span><br><span class="line">            <span class="keyword">if</span> (each.getLogicTable().equals(logicTableName.toLowerCase())) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Deduce actual table name from other actual table name in same binding table rule.</span></span><br><span class="line"><span class="comment">     * 从同一绑定表规则中的其他实际表名中推导出该逻辑表的实际表名。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dataSource data source name</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> logicTable logic table name</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> otherActualTable other actual table name in same binding table rule</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> actual table name</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getBindingActualTable</span><span class="params">(<span class="keyword">final</span> String dataSource, <span class="keyword">final</span> String logicTable, <span class="keyword">final</span> String otherActualTable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 找出其它实际表（子表或者父表）所在的位置(index)</span></span><br><span class="line">        <span class="keyword">for</span> (TableRule each : tableRules) &#123;</span><br><span class="line">            index = each.findActualTableIndex(dataSource, otherActualTable);</span><br><span class="line">            <span class="keyword">if</span> (-<span class="number">1</span> != index) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Preconditions.checkState(-<span class="number">1</span> != index, String.format(<span class="string">"Actual table [%s].[%s] is not in table config"</span>, dataSource, otherActualTable));</span><br><span class="line">        <span class="comment">// 根据其他实际表所在的位置(index)获取当前位置的logicTable对应的实际表</span></span><br><span class="line">        <span class="keyword">for</span> (TableRule each : tableRules) &#123;</span><br><span class="line">            <span class="keyword">if</span> (each.getLogicTable().equals(logicTable.toLowerCase())) &#123;</span><br><span class="line">                <span class="keyword">return</span> each.getActualDataNodes().get(index).getTableName().toLowerCase();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(String.format(<span class="string">"Cannot find binding actual table, data source: %s, logic table: %s, other actual table: %s"</span>, dataSource, logicTable, otherActualTable));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 所有逻辑表</span></span><br><span class="line">    <span class="function">Collection&lt;String&gt; <span class="title">getAllLogicTables</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Lists.transform(tableRules, <span class="keyword">new</span> Function&lt;TableRule, String&gt;() &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">apply</span><span class="params">(<span class="keyword">final</span> TableRule input)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> input.getLogicTable().toLowerCase();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="路由解析"><a href="#路由解析" class="headerlink" title="路由解析"></a>路由解析</h4><p>路由逻辑：</p>
<ol>
<li>shardingRule获取TableRule，如果当前表有绑定表且已经保存，则忽略当前表；</li>
<li>若没有绑定表或有绑定表但绑定的表未保存，则使用SimpleRoutingEngine路由，保存路由结果；</li>
<li>获取当前表的绑定表并保存；</li>
<li>如果只有一个SimpleRoutingEngine路由结果，就返回路由结果；</li>
<li>多个路由结果，就使用<a href="####笛卡尔路由引擎(CartesianRoutingEngine">CartesianRoutingEngine</a>)再路由。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ComplexRoutingEngine</span> <span class="keyword">implements</span> <span class="title">RoutingEngine</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ShardingRule shardingRule;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Object&gt; parameters;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Collection&lt;String&gt; logicTables;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SQLStatement sqlStatement;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RoutingResult <span class="title">route</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Collection&lt;RoutingResult&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;(logicTables.size());</span><br><span class="line">        Collection&lt;String&gt; bindingTableNames = <span class="keyword">new</span> TreeSet&lt;&gt;(String.CASE_INSENSITIVE_ORDER);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * logicTables: customer_track,customer_track_detail</span></span><br><span class="line"><span class="comment">        * customer_track会使用SimpleRoutingEngine().route()进行路由</span></span><br><span class="line"><span class="comment">        * customer_track_detail因为和customer_track是绑定关系会按照customer_track的路由结果</span></span><br><span class="line"><span class="comment">        **/</span></span><br><span class="line">        <span class="keyword">for</span> (String each : logicTables) &#123;</span><br><span class="line">            <span class="comment">// 查找当前表的规则</span></span><br><span class="line">            Optional&lt;TableRule&gt; tableRule = shardingRule.tryFindTableRule(each);</span><br><span class="line">            <span class="keyword">if</span> (tableRule.isPresent()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!bindingTableNames.contains(each)) &#123;</span><br><span class="line">                    <span class="comment">// 绑定表的第一个表使用SimpleRoutingEngine路由，也就是使用设置的规则去路由</span></span><br><span class="line">                    result.add(<span class="keyword">new</span> SimpleRoutingEngine(shardingRule, parameters, tableRule.get().getLogicTable(), sqlStatement).route());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//查找绑定表规则</span></span><br><span class="line">                Optional&lt;BindingTableRule&gt; bindingTableRule = shardingRule.findBindingTableRule(each);</span><br><span class="line">                <span class="keyword">if</span> (bindingTableRule.isPresent()) &#123;</span><br><span class="line">                    bindingTableNames.addAll(Lists.transform(bindingTableRule.get().getTableRules(), <span class="keyword">new</span> Function&lt;TableRule, String&gt;() &#123;</span><br><span class="line">                        </span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> String <span class="title">apply</span><span class="params">(<span class="keyword">final</span> TableRule input)</span> </span>&#123;</span><br><span class="line">                            <span class="keyword">return</span> input.getLogicTable();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        log.trace(<span class="string">"mixed tables sharding result: &#123;&#125;"</span>, result);</span><br><span class="line">        <span class="keyword">if</span> (result.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ShardingJdbcException(<span class="string">"Cannot find table rule and default data source with logic tables: '%s'"</span>, logicTables);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 都是互相绑定的表，路由一致</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">1</span> == result.size()) &#123;</span><br><span class="line">            <span class="keyword">return</span> result.iterator().next();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 使用笛卡尔路由</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CartesianRoutingEngine(result).route();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="笛卡尔路由引擎-CartesianRoutingEngine"><a href="#笛卡尔路由引擎-CartesianRoutingEngine" class="headerlink" title="笛卡尔路由引擎(CartesianRoutingEngine)"></a>笛卡尔路由引擎(CartesianRoutingEngine)</h4><p>笛卡尔路由引擎的前提是有多个<a href="####路由解析">SimpleRoutingEngine路由结果</a>。</p>
<p>路由逻辑：<br>将所有的路由结果使用<a href="#####卡迪尔路由结果(CartesianRoutingResult">CartesianRoutingResult</a>)按DataSource分类保存。</p>
<p>直接看CartesianRoutingEngine的route方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CartesianRoutingEngine</span> <span class="keyword">implements</span> <span class="title">RoutingEngine</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 路由结果，构造器阶段传入</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Collection&lt;RoutingResult&gt; routingResults;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CartesianRoutingResult <span class="title">route</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CartesianRoutingResult result = <span class="keyword">new</span> CartesianRoutingResult();</span><br><span class="line">        <span class="comment">// key是datasource名称，value是逻辑表名列表</span></span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;String, Set&lt;String&gt;&gt; entry : getDataSourceLogicTablesMap().entrySet()) &#123;</span><br><span class="line">            <span class="comment">// 根据逻辑表获取实际表名</span></span><br><span class="line">            List&lt;Set&lt;String&gt;&gt; actualTableGroups = getActualTableGroups(entry.getKey(), entry.getValue());</span><br><span class="line">            <span class="comment">// 封装成TableUnit</span></span><br><span class="line">            List&lt;Set&lt;TableUnit&gt;&gt; tableUnitGroups = toTableUnitGroups(entry.getKey(), actualTableGroups);</span><br><span class="line">            <span class="comment">// getCartesianTableReferences将TableUnit转成CartesianTableReference</span></span><br><span class="line">            <span class="comment">// 合并详见CartesianRoutingResult</span></span><br><span class="line">            result.merge(entry.getKey(), getCartesianTableReferences(Sets.cartesianProduct(tableUnitGroups)));</span><br><span class="line">        &#125;</span><br><span class="line">        log.trace(<span class="string">"cartesian tables sharding result: &#123;&#125;"</span>, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// key是datasource名称，value是逻辑表名列表</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Set&lt;String&gt;&gt; getDataSourceLogicTablesMap() &#123;</span><br><span class="line">        <span class="comment">// 获取DataSource的交集</span></span><br><span class="line">        Collection&lt;String&gt; intersectionDataSources = getIntersectionDataSources();</span><br><span class="line">        <span class="comment">// key是datasource名称，value是逻辑表名列表</span></span><br><span class="line">        Map&lt;String, Set&lt;String&gt;&gt; result = <span class="keyword">new</span> HashMap&lt;&gt;(routingResults.size());</span><br><span class="line">        <span class="keyword">for</span> (RoutingResult each : routingResults) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Entry&lt;String, Set&lt;String&gt;&gt; entry : each.getTableUnits().getDataSourceLogicTablesMap(intersectionDataSources).entrySet()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (result.containsKey(entry.getKey())) &#123;</span><br><span class="line">                    result.get(entry.getKey()).addAll(entry.getValue());</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    result.put(entry.getKey(), entry.getValue());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 取routingResults的DataSource交集</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Collection&lt;String&gt; <span class="title">getIntersectionDataSources</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Collection&lt;String&gt; result = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (RoutingResult each : routingResults) &#123;</span><br><span class="line">            <span class="keyword">if</span> (result.isEmpty()) &#123;</span><br><span class="line">                result.addAll(each.getTableUnits().getDataSourceNames());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// retainAll 取交集</span></span><br><span class="line">            result.retainAll(each.getTableUnits().getDataSourceNames());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> List&lt;Set&lt;String&gt;&gt; getActualTableGroups(<span class="keyword">final</span> String dataSource, <span class="keyword">final</span> Set&lt;String&gt; logicTables) &#123;</span><br><span class="line">        List&lt;Set&lt;String&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;(logicTables.size());</span><br><span class="line">        <span class="keyword">for</span> (RoutingResult each : routingResults) &#123;</span><br><span class="line">            result.addAll(each.getTableUnits().getActualTableNameGroups(dataSource, logicTables));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> List&lt;Set&lt;TableUnit&gt;&gt; toTableUnitGroups(<span class="keyword">final</span> String dataSource, <span class="keyword">final</span> List&lt;Set&lt;String&gt;&gt; actualTableGroups) &#123;</span><br><span class="line">        List&lt;Set&lt;TableUnit&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;(actualTableGroups.size());</span><br><span class="line">        <span class="keyword">for</span> (Set&lt;String&gt; each : actualTableGroups) &#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> HashSet&lt;&gt;(Lists.transform(<span class="keyword">new</span> ArrayList&lt;&gt;(each), <span class="keyword">new</span> Function&lt;String, TableUnit&gt;() &#123;</span><br><span class="line">    </span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> TableUnit <span class="title">apply</span><span class="params">(<span class="keyword">final</span> String input)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> findTableUnit(dataSource, input);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> TableUnit <span class="title">findTableUnit</span><span class="params">(<span class="keyword">final</span> String dataSource, <span class="keyword">final</span> String actualTable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (RoutingResult each : routingResults) &#123;</span><br><span class="line">            Optional&lt;TableUnit&gt; result = each.getTableUnits().findTableUnit(dataSource, actualTable);</span><br><span class="line">            <span class="keyword">if</span> (result.isPresent()) &#123;</span><br><span class="line">                <span class="keyword">return</span> result.get();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(String.format(<span class="string">"Cannot found routing table factor, data source: %s, actual table: %s"</span>, dataSource, actualTable));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> List&lt;CartesianTableReference&gt; <span class="title">getCartesianTableReferences</span><span class="params">(<span class="keyword">final</span> Set&lt;List&lt;TableUnit&gt;&gt; cartesianTableUnitGroups)</span> </span>&#123;</span><br><span class="line">        List&lt;CartesianTableReference&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;(cartesianTableUnitGroups.size());</span><br><span class="line">        <span class="keyword">for</span> (List&lt;TableUnit&gt; each : cartesianTableUnitGroups) &#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> CartesianTableReference(each));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="卡迪尔路由结果-CartesianRoutingResult"><a href="#卡迪尔路由结果-CartesianRoutingResult" class="headerlink" title="卡迪尔路由结果(CartesianRoutingResult)"></a>卡迪尔路由结果(CartesianRoutingResult)</h5><p>merge逻辑：</p>
<ol>
<li>将routingTableReferences按照dataSource分类保存。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CartesianRoutingResult</span> <span class="keyword">extends</span> <span class="title">RoutingResult</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Getter</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;CartesianDataSource&gt; routingDataSources = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">final</span> String dataSource, <span class="keyword">final</span> Collection&lt;CartesianTableReference&gt; routingTableReferences)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (CartesianTableReference each : routingTableReferences) &#123;</span><br><span class="line">            merge(dataSource, each);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">final</span> String dataSource, <span class="keyword">final</span> CartesianTableReference routingTableReference)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// routingDataSources 中已有该dataSource，就添加表引用(routingTableReference)</span></span><br><span class="line">        <span class="keyword">for</span> (CartesianDataSource each : routingDataSources) &#123;</span><br><span class="line">            <span class="keyword">if</span> (each.getDataSource().equalsIgnoreCase(dataSource)) &#123;</span><br><span class="line">                each.getRoutingTableReferences().add(routingTableReference);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// routingDataSources 中没有该dataSource</span></span><br><span class="line">        routingDataSources.add(<span class="keyword">new</span> CartesianDataSource(dataSource, routingTableReference));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSingleRouting</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Collection&lt;CartesianTableReference&gt; cartesianTableReferences = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (CartesianDataSource cartesianDataSource : routingDataSources) &#123;</span><br><span class="line">            <span class="keyword">for</span> (CartesianTableReference cartesianTableReference : cartesianDataSource.getRoutingTableReferences()) &#123;</span><br><span class="line">                cartesianTableReferences.add(cartesianTableReference);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> == cartesianTableReferences.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>CartesianRoutingResult继承了RoutingResult类，但并没有给RoutingResult的属性<code>TableUnits tableUnits</code>赋值，所以在实际使用CartesianRoutingResult类获取路由结果时，必然不能使用统一代码处理。</strong></p>
<p>CartesianRoutingResult在ParsingSQLRouter.route()中单独处理。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SQLRouteResult <span class="title">route</span><span class="params">(<span class="keyword">final</span> String logicSQL, <span class="keyword">final</span> List&lt;Object&gt; parameters, <span class="keyword">final</span> SQLStatement sqlStatement)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...省略无关代码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// route()执行了上文的路由过程，获得CartesianRoutingResult</span></span><br><span class="line">    RoutingResult routingResult = route(parameters, sqlStatement);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 这里CartesianRoutingResult单独处理</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    <span class="keyword">if</span> (routingResult <span class="keyword">instanceof</span> CartesianRoutingResult) &#123;</span><br><span class="line">        <span class="keyword">for</span> (CartesianDataSource cartesianDataSource : ((CartesianRoutingResult) routingResult).getRoutingDataSources()) &#123;</span><br><span class="line">            <span class="comment">// cartesianTableReference中包含了一个db中的所有实际表名</span></span><br><span class="line">            <span class="keyword">for</span> (CartesianTableReference cartesianTableReference : cartesianDataSource.getRoutingTableReferences()) &#123;</span><br><span class="line">                result.getExecutionUnits().add(<span class="keyword">new</span> SQLExecutionUnit(cartesianDataSource.getDataSource(), rewriteEngine.generateSQL(cartesianTableReference, sqlBuilder)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 通用处理</span></span><br><span class="line">        <span class="keyword">for</span> (TableUnit each : routingResult.getTableUnits().getTableUnits()) &#123;</span><br><span class="line">            result.getExecutionUnits().add(<span class="keyword">new</span> SQLExecutionUnit(each.getDataSourceName(), rewriteEngine.generateSQL(each, sqlBuilder)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (showSQL) &#123;</span><br><span class="line">        SQLLogger.logSQL(logicSQL, sqlStatement, result.getExecutionUnits(), parameters);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="sql改写-SQLRewriteEngine"><a href="#sql改写-SQLRewriteEngine" class="headerlink" title="sql改写(SQLRewriteEngine)"></a>sql改写(SQLRewriteEngine)</h2><p><img src="https://i.loli.net/2018/11/19/5bf2a9af51d51.png" alt="sql改写.png"></p>
<p>sql改写发生在.ParsingSQLRouter.route()-&gt;rewriteEngine.rewrite()。</p>
<p>sql改写在SQLRewriteEngine类中，有两个核心方法：</p>
<ol>
<li>rewrite方法：负责将sql语句改写，并分割成块，结构例如:<br><br>select * from, tableToken, where id=? </li>
<li>generateSQL方法：负责生成改写后的sql语句，这里主要对表名进行替换。</li>
</ol>
<p>SQLRewriteEngine改写了表名、limit的偏移量和行数。</p>
<p><strong>SQLBuilder</strong></p>
<p>先认识一下rewrite方法执行后保存sql段的类SQLBuilder。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SQLBuilder</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 保存sql段</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Object&gt; segments;</span><br><span class="line">    <span class="comment">// 用于保存不改变的sql</span></span><br><span class="line">    <span class="keyword">private</span> StringBuilder currentSegment;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SQLBuilder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        segments = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        currentSegment = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        segments.add(currentSegment);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 保存不变的sql</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">appendLiterals</span><span class="params">(<span class="keyword">final</span> String literals)</span> </span>&#123;</span><br><span class="line">        currentSegment.append(literals);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 保存table段</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">appendTable</span><span class="params">(<span class="keyword">final</span> String tableName)</span> </span>&#123;</span><br><span class="line">        segments.add(<span class="keyword">new</span> TableToken(tableName));</span><br><span class="line">        currentSegment = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        segments.add(currentSegment);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 保存index段</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">appendIndex</span><span class="params">(<span class="keyword">final</span> String indexName, <span class="keyword">final</span> String tableName)</span> </span>&#123;</span><br><span class="line">        segments.add(<span class="keyword">new</span> IndexToken(indexName, tableName));</span><br><span class="line">        currentSegment = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        segments.add(currentSegment);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 生成改写后的sql语句</span></span><br><span class="line">    <span class="comment">// tableTokens: &lt;逻辑表名&gt;:&lt;实际表名&gt;</span></span><br><span class="line">    <span class="comment">// customer_track:customer_track_1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toSQL</span><span class="params">(<span class="keyword">final</span> Map&lt;String, String&gt; tableTokens)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 保存最终的sql语句</span></span><br><span class="line">        StringBuilder result = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (Object each : segments) &#123;</span><br><span class="line">            <span class="comment">// 替换表名</span></span><br><span class="line">            <span class="keyword">if</span> (each <span class="keyword">instanceof</span> TableToken &amp;&amp; tableTokens.containsKey(((TableToken) each).tableName)) &#123;</span><br><span class="line">                result.append(tableTokens.get(((TableToken) each).tableName));</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (each <span class="keyword">instanceof</span> IndexToken) &#123;</span><br><span class="line">                <span class="comment">// 索引替换表名</span></span><br><span class="line">                IndexToken indexToken = (IndexToken) each;</span><br><span class="line">                result.append(indexToken.indexName);</span><br><span class="line">                String tableName = tableTokens.get(indexToken.tableName);</span><br><span class="line">                <span class="keyword">if</span> (!Strings.isNullOrEmpty(tableName)) &#123;</span><br><span class="line">                    result.append(<span class="string">"_"</span>);</span><br><span class="line">                    result.append(tableName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                result.append(each);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ... 省略其它</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>SQLRewriteEngine.rewrite()</strong><br>isRewriteLimit 由是否查询多个库表决定。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> SQLBuilder <span class="title">rewrite</span><span class="params">(<span class="keyword">final</span> <span class="keyword">boolean</span> isRewriteLimit)</span> </span>&#123;</span><br><span class="line">    SQLBuilder result = <span class="keyword">new</span> SQLBuilder();</span><br><span class="line">    <span class="keyword">if</span> (sqlTokens.isEmpty()) &#123;</span><br><span class="line">        result.appendLiterals(originalSQL);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    sortByBeginPosition();</span><br><span class="line">    <span class="keyword">for</span> (SQLToken each : sqlTokens) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == count) &#123;</span><br><span class="line">            <span class="comment">// sql语句最前面一段不用修改的内容保存</span></span><br><span class="line">            result.appendLiterals(originalSQL.substring(<span class="number">0</span>, each.getBeginPosition()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (each <span class="keyword">instanceof</span> TableToken) &#123;</span><br><span class="line">            appendTableToken(result, (TableToken) each, count, sqlTokens);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (each <span class="keyword">instanceof</span> IndexToken) &#123;</span><br><span class="line">            appendIndexToken(result, (IndexToken) each, count, sqlTokens);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (each <span class="keyword">instanceof</span> ItemsToken) &#123;</span><br><span class="line">            appendItemsToken(result, (ItemsToken) each, count, sqlTokens);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (each <span class="keyword">instanceof</span> RowCountToken) &#123;</span><br><span class="line">            appendLimitRowCount(result, (RowCountToken) each, count, sqlTokens, isRewriteLimit);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (each <span class="keyword">instanceof</span> OffsetToken) &#123;</span><br><span class="line">            appendLimitOffsetToken(result, (OffsetToken) each, count, sqlTokens, isRewriteLimit);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (each <span class="keyword">instanceof</span> OrderByToken) &#123;</span><br><span class="line">            appendOrderByToken(result, count, sqlTokens);</span><br><span class="line">        &#125;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>SQLRewriteEngine.generateSQL()</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">generateSQL</span><span class="params">(<span class="keyword">final</span> TableUnit tableUnit, <span class="keyword">final</span> SQLBuilder sqlBuilder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sqlBuilder.toSQL(getTableTokens(tableUnit));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="表名改写-TableToken"><a href="#表名改写-TableToken" class="headerlink" title="表名改写(TableToken)"></a>表名改写(TableToken)</h3><p>sql的表名替换在生成sql语句时替换SQLRewriteEngine.generateSQL()，改写规则：将逻辑表替换成实际的物理表。<br>详见上面：</p>
<blockquote>
<p>SQLRewriteEngine.generateSQL() -&gt; SQLBuilder.toSQL()</p>
</blockquote>
<h3 id="索引改写-IndexToken"><a href="#索引改写-IndexToken" class="headerlink" title="索引改写(IndexToken)"></a>索引改写(IndexToken)</h3><p>索引改写就是将逻辑表索引改为实际物理表索引index_tableName，所以逻辑与表名改写一致。</p>
<h3 id="分页改写"><a href="#分页改写" class="headerlink" title="分页改写"></a>分页改写</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SQLRouteResult <span class="title">route</span><span class="params">(<span class="keyword">final</span> String logicSQL, <span class="keyword">final</span> List&lt;Object&gt; parameters, <span class="keyword">final</span> SQLStatement sqlStatement)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">if</span> (sqlStatement <span class="keyword">instanceof</span> SelectStatement &amp;&amp; <span class="keyword">null</span> != ((SelectStatement) sqlStatement).getLimit()) &#123;</span><br><span class="line">        processLimit(parameters, (SelectStatement) sqlStatement, isSingleRouting);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分页如果在limit中有占位符就会在ParsingSQLRouter.route() -&gt; ParsingSQLRouter.processLimit()中作前置处理。</p>
<h4 id="Limit带占位符前置处理"><a href="#Limit带占位符前置处理" class="headerlink" title="Limit带占位符前置处理"></a>Limit带占位符前置处理</h4><p>processLimit()如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processLimit</span><span class="params">(<span class="keyword">final</span> List&lt;Object&gt; parameters, <span class="keyword">final</span> SelectStatement selectStatement, <span class="keyword">final</span> <span class="keyword">boolean</span> isSingleRouting)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 只查一个库表时</span></span><br><span class="line">    <span class="keyword">if</span> (isSingleRouting) &#123;</span><br><span class="line">        selectStatement.setLimit(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 是否查所有，有group by/聚合函数且分组字段与排序字段不一致</span></span><br><span class="line">    <span class="keyword">boolean</span> isNeedFetchAll = (!selectStatement.getGroupByItems().isEmpty() || !selectStatement.getAggregationSelectItems().isEmpty()) &amp;&amp; !selectStatement.isSameGroupByAndOrderByItems();</span><br><span class="line">    <span class="comment">// 改写</span></span><br><span class="line">    selectStatement.getLimit().processParameters(parameters, isNeedFetchAll);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>改写在Limit类中，parameters占位符对应的参数，改写逻辑如下：</p>
<ol>
<li>行数根据isFetchAll，true设置行数为最大Integer；不然要是数据库是MySQL/H2/PostgreSQL则设置成Offset + rowCount；其他就是参数传多少就是多少；</li>
<li>偏移量直接设置成0；</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processParameters</span><span class="params">(<span class="keyword">final</span> List&lt;Object&gt; parameters, <span class="keyword">final</span> <span class="keyword">boolean</span> isFetchAll)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将limit占位的值获取，并设置到offset和rowCount</span></span><br><span class="line">    fill(parameters);</span><br><span class="line">    <span class="comment">// 重写</span></span><br><span class="line">    rewrite(parameters, isFetchAll);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fill</span><span class="params">(<span class="keyword">final</span> List&lt;Object&gt; parameters)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> offset = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != <span class="keyword">this</span>.offset) &#123;</span><br><span class="line">        <span class="comment">// offset.getIndex() !=-1，取对应占位的参数值</span></span><br><span class="line">        offset = -<span class="number">1</span> == <span class="keyword">this</span>.offset.getIndex() ? getOffsetValue() : NumberUtil.roundHalfUp(parameters.get(<span class="keyword">this</span>.offset.getIndex()));</span><br><span class="line">        <span class="keyword">this</span>.offset.setValue(offset);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> rowCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != <span class="keyword">this</span>.rowCount) &#123;</span><br><span class="line">        <span class="comment">// rowCount.getIndex() !=-1，取对应占位的参数值</span></span><br><span class="line">        rowCount = -<span class="number">1</span> == <span class="keyword">this</span>.rowCount.getIndex() ? getRowCountValue() : NumberUtil.roundHalfUp(parameters.get(<span class="keyword">this</span>.rowCount.getIndex()));</span><br><span class="line">        <span class="keyword">this</span>.rowCount.setValue(rowCount);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (offset &lt; <span class="number">0</span> || rowCount &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SQLParsingException(<span class="string">"LIMIT offset and row count can not be a negative value."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rewrite</span><span class="params">(<span class="keyword">final</span> List&lt;Object&gt; parameters, <span class="keyword">final</span> <span class="keyword">boolean</span> isFetchAll)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rewriteOffset = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> rewriteRowCount;</span><br><span class="line">    <span class="comment">// 行数设置最大Integer，也就是不分页</span></span><br><span class="line">    <span class="keyword">if</span> (isFetchAll) &#123;</span><br><span class="line">        rewriteRowCount = Integer.MAX_VALUE;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isNeedRewriteRowCount()) &#123;</span><br><span class="line">        <span class="comment">// 行数设置成 Offset + rowCount</span></span><br><span class="line">        rewriteRowCount = <span class="keyword">null</span> == rowCount ? -<span class="number">1</span> : getOffsetValue() + rowCount.getValue();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        rewriteRowCount = rowCount.getValue();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 偏移量offset 直接设置成0</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != offset &amp;&amp; offset.getIndex() &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">        parameters.set(offset.getIndex(), rewriteOffset);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != rowCount &amp;&amp; rowCount.getIndex() &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">        parameters.set(rowCount.getIndex(), rewriteRowCount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNeedRewriteRowCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> DatabaseType.MySQL == databaseType || DatabaseType.PostgreSQL == databaseType || DatabaseType.H2 == databaseType;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="行数改写-RowCountToken"><a href="#行数改写-RowCountToken" class="headerlink" title="行数改写(RowCountToken)"></a>行数改写(RowCountToken)</h4><p>改写limit的行数在SQLRewriteEngine.rewrite()，改写规则如下：</p>
<ol>
<li>只查一个库表的不改写；</li>
<li>有group by或聚合函数且分组字段与排序字段不相同，则设置行数为Integer.MAX_VALUE，即数据库分页；</li>
<li>有group by或聚合函数且分组字段与排序字段相同，行数 = offset+行数</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">appendLimitRowCount</span><span class="params">(<span class="keyword">final</span> SQLBuilder sqlBuilder, <span class="keyword">final</span> RowCountToken rowCountToken, </span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">final</span> <span class="keyword">int</span> count, <span class="keyword">final</span> List&lt;SQLToken&gt; sqlTokens, <span class="keyword">final</span> <span class="keyword">boolean</span> isRewrite)</span> </span>&#123;</span><br><span class="line">    SelectStatement selectStatement = (SelectStatement) sqlStatement;</span><br><span class="line">    Limit limit = selectStatement.getLimit();</span><br><span class="line">    <span class="comment">// isRewrite 是根据是否需要查询多个库表决定的</span></span><br><span class="line">    <span class="keyword">if</span> (!isRewrite) &#123; <span class="comment">// 不改写limit</span></span><br><span class="line">        sqlBuilder.appendLiterals(String.valueOf(rowCountToken.getRowCount()));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((!selectStatement.getGroupByItems().isEmpty() || !selectStatement.getAggregationSelectItems().isEmpty()) &amp;&amp; !selectStatement.isSameGroupByAndOrderByItems()) &#123;</span><br><span class="line">        <span class="comment">// 有group by 或 聚合函数并且group by字段与排序字段不相同，设置行数为最大值Integer.MAX_VALUE</span></span><br><span class="line">        sqlBuilder.appendLiterals(String.valueOf(Integer.MAX_VALUE));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// isNeedRewriteRowCount 只要MySQL/PostgreSQL/H2就需要，到这里的条件是group by字段与排序字段相同</span></span><br><span class="line">        sqlBuilder.appendLiterals(String.valueOf(limit.isNeedRewriteRowCount() ? rowCountToken.getRowCount() + limit.getOffsetValue() : rowCountToken.getRowCount()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> beginPosition = rowCountToken.getBeginPosition() + String.valueOf(rowCountToken.getRowCount()).length();</span><br><span class="line">    appendRest(sqlBuilder, count, sqlTokens, beginPosition);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="偏移量-Offset-改写-OffsetToken"><a href="#偏移量-Offset-改写-OffsetToken" class="headerlink" title="偏移量(Offset)改写(OffsetToken)"></a>偏移量(Offset)改写(OffsetToken)</h4><p>改写limit的偏移量(Offset)在SQLRewriteEngine.rewrite()，改写规则如下：</p>
<ol>
<li>需要查询多个库表就直接把offset设为0</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">appendLimitOffsetToken</span><span class="params">(<span class="keyword">final</span> SQLBuilder sqlBuilder, <span class="keyword">final</span> OffsetToken offsetToken, </span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">final</span> <span class="keyword">int</span> count, <span class="keyword">final</span> List&lt;SQLToken&gt; sqlTokens, <span class="keyword">final</span> <span class="keyword">boolean</span> isRewrite)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// isRewrite 是根据是否需要查询多个库表决定的</span></span><br><span class="line">    <span class="comment">// 有多个库表查询就直接把offset设为0</span></span><br><span class="line">    sqlBuilder.appendLiterals(isRewrite ? <span class="string">"0"</span> : String.valueOf(offsetToken.getOffset()));</span><br><span class="line">    <span class="keyword">int</span> beginPosition = offsetToken.getBeginPosition() + String.valueOf(offsetToken.getOffset()).length();</span><br><span class="line">    appendRest(sqlBuilder, count, sqlTokens, beginPosition);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="排序-OrderByToken"><a href="#排序-OrderByToken" class="headerlink" title="排序(OrderByToken)"></a>排序(OrderByToken)</h3><p>在SQLRewriteEngine.rewrite()中没有对排序进行改写，appendOrderByToken()根据解析的SelectStatement生成order by的语句。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">appendOrderByToken</span><span class="params">(<span class="keyword">final</span> SQLBuilder sqlBuilder, <span class="keyword">final</span> <span class="keyword">int</span> count, <span class="keyword">final</span> List&lt;SQLToken&gt; sqlTokens)</span> </span>&#123;</span><br><span class="line">    SelectStatement selectStatement = (SelectStatement) sqlStatement;</span><br><span class="line">    StringBuilder orderByLiterals = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    orderByLiterals.append(<span class="string">" "</span>).append(DefaultKeyword.ORDER).append(<span class="string">" "</span>).append(DefaultKeyword.BY).append(<span class="string">" "</span>);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 添加order by的字段</span></span><br><span class="line">    <span class="keyword">for</span> (OrderItem each : selectStatement.getOrderByItems()) &#123;</span><br><span class="line">        String columnLabel = SQLUtil.getOriginalValue(each.getColumnLabel(), databaseType);</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == i) &#123;</span><br><span class="line">            orderByLiterals.append(columnLabel).append(<span class="string">" "</span>).append(each.getType().name());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            orderByLiterals.append(<span class="string">","</span>).append(columnLabel).append(<span class="string">" "</span>).append(each.getType().name());</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    orderByLiterals.append(<span class="string">" "</span>);</span><br><span class="line">    <span class="comment">// order by 的sql段加入到sqlBuilder中</span></span><br><span class="line">    sqlBuilder.appendLiterals(orderByLiterals.toString());</span><br><span class="line">    <span class="keyword">int</span> beginPosition = ((SelectStatement) sqlStatement).getGroupByLastPosition();</span><br><span class="line">    appendRest(sqlBuilder, count, sqlTokens, beginPosition);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="结果归并"><a href="#结果归并" class="headerlink" title="结果归并"></a>结果归并</h2><p>结果归并在ShardingPreparedStatement.executeQuery()-&gt;MergeEngine.merge()中执行：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ResultSet <span class="title">executeQuery</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    ResultSet result;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 路由完成</span></span><br><span class="line">        Collection&lt;PreparedStatementUnit&gt; preparedStatementUnits = route();</span><br><span class="line">        <span class="comment">// 执行sql</span></span><br><span class="line">        List&lt;ResultSet&gt; resultSets = <span class="keyword">new</span> PreparedStatementExecutor(</span><br><span class="line">                getConnection().getShardingContext().getExecutorEngine(), routeResult.getSqlStatement().getType(), preparedStatementUnits, getParameters()).executeQuery();</span><br><span class="line">        <span class="comment">// 结果归并</span></span><br><span class="line">        result = <span class="keyword">new</span> ShardingResultSet(resultSets, <span class="keyword">new</span> MergeEngine(resultSets, (SelectStatement) routeResult.getSqlStatement()).merge(), <span class="keyword">this</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        clearBatch();</span><br><span class="line">    &#125;</span><br><span class="line">    currentResultSet = result;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="无归并-IteratorStreamResultSetMerger"><a href="#无归并-IteratorStreamResultSetMerger" class="headerlink" title="无归并(IteratorStreamResultSetMerger)"></a>无归并(IteratorStreamResultSetMerger)</h3><p>没有排序、group、聚合函数的查询会封装成IteratorStreamResultSetMerger。</p>
<p>IteratorStreamResultSetMerger中依次迭代结果集。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">IteratorStreamResultSetMerger</span> <span class="keyword">extends</span> <span class="title">AbstractStreamResultSetMerger</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Iterator&lt;ResultSet&gt; resultSets;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IteratorStreamResultSetMerger</span><span class="params">(<span class="keyword">final</span> List&lt;ResultSet&gt; resultSets)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.resultSets = resultSets.iterator();</span><br><span class="line">        setCurrentResultSet(<span class="keyword">this</span>.resultSets.next());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">next</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (getCurrentResultSet().next()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!resultSets.hasNext()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 迭代结果集</span></span><br><span class="line">        setCurrentResultSet(resultSets.next());</span><br><span class="line">        <span class="keyword">boolean</span> hasNext = getCurrentResultSet().next();</span><br><span class="line">        <span class="keyword">if</span> (hasNext) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!hasNext &amp;&amp; resultSets.hasNext()) &#123;</span><br><span class="line">            setCurrentResultSet(resultSets.next());</span><br><span class="line">            hasNext = getCurrentResultSet().next();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hasNext;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="排序归并-OrderByStreamResultSetMerger"><a href="#排序归并-OrderByStreamResultSetMerger" class="headerlink" title="排序归并(OrderByStreamResultSetMerger)"></a>排序归并(OrderByStreamResultSetMerger)</h3><p><img src="https://i.loli.net/2018/11/19/5bf2a90055edc.png" alt="OrderByStreamResultSetMerger序列图.png"></p>
<p><strong>排序逻辑</strong></p>
<ol>
<li>利用优先级队列，比较各结果集当前行排序字段值，按比较结果排列结果集；</li>
<li>取队列头的结果集的一行数据；</li>
<li>运行next()方法，将队列头的结果集取出队列，执行该结果集的next()方法使光标指向下一行，再将该结果集存入队列排序；</li>
</ol>
<p><strong>属性</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderByStreamResultSetMerger</span> <span class="keyword">extends</span> <span class="title">AbstractStreamResultSetMerger</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 排序字段信息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;OrderItem&gt; orderByItems;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 结果集队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Queue&lt;OrderByValue&gt; orderByValuesQueue;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isFirstNext;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>构造器</strong></p>
<p>构造器中将结果集以<code>OrderByValue类</code>的形式存入优先级队列中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">OrderByStreamResultSetMerger</span><span class="params">(<span class="keyword">final</span> List&lt;ResultSet&gt; resultSets, <span class="keyword">final</span> 			List&lt;OrderItem&gt; orderByItems)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.orderByItems = orderByItems;</span><br><span class="line">    <span class="keyword">this</span>.orderByValuesQueue = <span class="keyword">new</span> PriorityQueue&lt;&gt;(resultSets.size());</span><br><span class="line">    <span class="comment">// 存入优先级队列</span></span><br><span class="line">    orderResultSetsToQueue(resultSets);</span><br><span class="line">    isFirstNext = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">orderResultSetsToQueue</span><span class="params">(<span class="keyword">final</span> List&lt;ResultSet&gt; resultSets)</span> <span class="keyword">throws</span> 			SQLException </span>&#123;</span><br><span class="line">    <span class="comment">// 遍历存入队列</span></span><br><span class="line">    <span class="keyword">for</span> (ResultSet each : resultSets) &#123;</span><br><span class="line">        OrderByValue orderByValue = <span class="keyword">new</span> OrderByValue(each, orderByItems);</span><br><span class="line">        <span class="keyword">if</span> (orderByValue.next()) &#123;</span><br><span class="line">            orderByValuesQueue.offer(orderByValue);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置当前结果集为队列头元素</span></span><br><span class="line">    setCurrentResultSet(orderByValuesQueue.isEmpty() ? resultSets.get(<span class="number">0</span>) : 				orderByValuesQueue.peek().getResultSet());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>next()方法</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">next</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (orderByValuesQueue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isFirstNext) &#123;</span><br><span class="line">        isFirstNext = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 取出队列头部元素</span></span><br><span class="line">    OrderByValue firstOrderByValue = orderByValuesQueue.poll();</span><br><span class="line">    <span class="comment">// 光标移动</span></span><br><span class="line">    <span class="keyword">if</span> (firstOrderByValue.next()) &#123;</span><br><span class="line">        <span class="comment">// 存入队列，重排序</span></span><br><span class="line">        orderByValuesQueue.offer(firstOrderByValue);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (orderByValuesQueue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置当前结果集</span></span><br><span class="line">    setCurrentResultSet(orderByValuesQueue.peek().getResultSet());</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>OrderByValue类</strong></p>
<ol>
<li>OrderByStreamResultSetMerger的优先级队列通过OrderByValue实现的Comparable接口来判断优先级；</li>
<li>OrderByValue的比较的逻辑是依次比较排序字段的值的大小，第一个不相等的排序字段大小代表了OrderByValue的大小（两个结果集中的光标指向行数据依次比较排序字段）；</li>
<li>OrderByValue的next()方法会在OrderByStreamResultSetMerger的next()方法中被调用；</li>
<li>OrderByValue的next()会推动结果集(resultSet.next())指向下一行。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderByValue</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">OrderByValue</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Getter</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ResultSet resultSet;</span><br><span class="line">    <span class="comment">// 排序字段信息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;OrderItem&gt; orderByItems;</span><br><span class="line">    <span class="comment">// 一行数据中包含排序字段的字段值</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Comparable&lt;?&gt;&gt; orderValues;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// next方法中会getOrderValues()获取当前行的排序字段值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">next</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="comment">// 调用结果集的next()方法</span></span><br><span class="line">        <span class="keyword">boolean</span> result = resultSet.next();</span><br><span class="line">        orderValues = result ? getOrderValues() : </span><br><span class="line">            Collections.&lt;Comparable&lt;?&gt;&gt;emptyList();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历orderByItems排序字段，获取对应的字段值</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Comparable&lt;?&gt;&gt; getOrderValues() <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        List&lt;Comparable&lt;?&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;(orderByItems.size());</span><br><span class="line">        <span class="keyword">for</span> (OrderItem each : orderByItems) &#123;</span><br><span class="line">            Object value = resultSet.getObject(each.getIndex());</span><br><span class="line">            Preconditions.checkState(<span class="keyword">null</span> == value || value <span class="keyword">instanceof</span> Comparable, <span class="string">"Order by value must implements Comparable"</span>);</span><br><span class="line">            result.add((Comparable&lt;?&gt;) value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 挨个比较排序字段的值，有一个不相等就返回</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(<span class="keyword">final</span> OrderByValue o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; orderByItems.size(); i++) &#123;</span><br><span class="line">            OrderItem thisOrderBy = orderByItems.get(i);</span><br><span class="line">            <span class="keyword">int</span> result = ResultSetUtil.compareTo(orderValues.get(i), o.orderValues.get(i), thisOrderBy.getType(), thisOrderBy.getNullOrderType());</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">0</span> != result) &#123;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="聚合函数结果归并"><a href="#聚合函数结果归并" class="headerlink" title="聚合函数结果归并"></a>聚合函数结果归并</h3><h4 id="GroupByStreamResultSetMerger-group-by-字段与排序字段相同"><a href="#GroupByStreamResultSetMerger-group-by-字段与排序字段相同" class="headerlink" title="GroupByStreamResultSetMerger(group by 字段与排序字段相同)"></a>GroupByStreamResultSetMerger(group by 字段与排序字段相同)</h4><p><img src="https://i.loli.net/2018/11/19/5bf2a87641d1d.png" alt="GroupByStreamResultSetMerger.png"></p>
<p><strong>属性</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupByStreamResultSetMerger</span> <span class="keyword">extends</span> <span class="title">OrderByStreamResultSetMerger</span> </span>&#123;</span><br><span class="line">    <span class="comment">// key字段名，value字段所在位置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Integer&gt; labelAndIndexMap;</span><br><span class="line">    <span class="comment">// sql</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SelectStatement selectStatement;</span><br><span class="line">    <span class="comment">// 当前行数据（归并处理后的数据）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Object&gt; currentRow;</span><br><span class="line">    <span class="comment">// group by字段值，用于归并判断，在更新currentRow数据后指向下一行</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;?&gt; currentGroupByValues;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>构造器</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">GroupByStreamResultSetMerger</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> Map&lt;String, Integer&gt; labelAndIndexMap, <span class="keyword">final</span> List&lt;ResultSet&gt; resultSets, <span class="keyword">final</span> SelectStatement selectStatement)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="comment">// OrderByStreamResultSetMerger 排序</span></span><br><span class="line">    <span class="keyword">super</span>(resultSets, selectStatement.getOrderByItems());</span><br><span class="line">    <span class="keyword">this</span>.labelAndIndexMap = labelAndIndexMap;</span><br><span class="line">    <span class="keyword">this</span>.selectStatement = selectStatement;</span><br><span class="line">    currentRow = <span class="keyword">new</span> ArrayList&lt;&gt;(labelAndIndexMap.size());</span><br><span class="line">    <span class="comment">// 获得group by 字段值</span></span><br><span class="line">    currentGroupByValues = getOrderByValuesQueue().isEmpty() ? Collections.emptyList() : <span class="keyword">new</span> GroupByValue(getCurrentResultSet(), selectStatement.getGroupByItems()).getGroupValues();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>读取数据</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getValue</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> columnIndex, <span class="keyword">final</span> Class&lt;?&gt; type)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> currentRow.get(columnIndex - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getValue</span><span class="params">(<span class="keyword">final</span> String columnLabel, <span class="keyword">final</span> Class&lt;?&gt; type)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    Preconditions.checkState(labelAndIndexMap.containsKey(columnLabel), String.format(<span class="string">"Can't find columnLabel: %s"</span>, columnLabel));</span><br><span class="line">    <span class="keyword">return</span> currentRow.get(labelAndIndexMap.get(columnLabel) - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>next()方法</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">next</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    currentRow.clear();</span><br><span class="line">    <span class="keyword">if</span> (getOrderByValuesQueue().isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isFirstNext()) &#123;</span><br><span class="line">        <span class="keyword">super</span>.next();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 归并</span></span><br><span class="line">    <span class="keyword">if</span> (aggregateCurrentGroupByRowAndNext()) &#123;</span><br><span class="line">        <span class="comment">// currentGroupByValues 指向下一行的group by 字段值</span></span><br><span class="line">        currentGroupByValues = <span class="keyword">new</span> GroupByValue(getCurrentResultSet(), selectStatement.getGroupByItems()).getGroupValues();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 归并</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">aggregateCurrentGroupByRowAndNext</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 聚集函数字段</span></span><br><span class="line">    Map&lt;AggregationSelectItem, AggregationUnit&gt; aggregationUnitMap = Maps.toMap(selectStatement.getAggregationSelectItems(), <span class="keyword">new</span> Function&lt;AggregationSelectItem, AggregationUnit&gt;() &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> AggregationUnit <span class="title">apply</span><span class="params">(<span class="keyword">final</span> AggregationSelectItem input)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> AggregationUnitFactory.create(input.getType());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//currentGroupByValues当前的group字段值，与各行group字段比较，直到group字段值不一致</span></span><br><span class="line">    <span class="comment">//第一次比较是自己比较自己</span></span><br><span class="line">    <span class="comment">//super.next()推动结果集走向下一行，同时保持排序</span></span><br><span class="line">    <span class="keyword">while</span> (currentGroupByValues.equals(<span class="keyword">new</span> GroupByValue(getCurrentResultSet(), selectStatement.getGroupByItems()).getGroupValues())) &#123;</span><br><span class="line">        <span class="comment">// 聚集函数结果归并，例如count()函数就相加，avg就平均等</span></span><br><span class="line">        aggregate(aggregationUnitMap);</span><br><span class="line">        <span class="comment">// 更新当前行的值，次数聚集函数的值不是归并后的值</span></span><br><span class="line">        cacheCurrentRow();</span><br><span class="line">        result = <span class="keyword">super</span>.next();</span><br><span class="line">        <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 此时将聚集函数归并后的值更新到相应的字段</span></span><br><span class="line">    setAggregationValueToCurrentRow(aggregationUnitMap);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">aggregate</span><span class="params">(<span class="keyword">final</span> Map&lt;AggregationSelectItem, AggregationUnit&gt; aggregationUnitMap)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;AggregationSelectItem, AggregationUnit&gt; entry : aggregationUnitMap.entrySet()) &#123;</span><br><span class="line">        List&lt;Comparable&lt;?&gt;&gt; values = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (entry.getKey().getDerivedAggregationSelectItems().isEmpty()) &#123;</span><br><span class="line">            values.add(getAggregationValue(entry.getKey()));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (AggregationSelectItem each : entry.getKey().getDerivedAggregationSelectItems()) &#123;</span><br><span class="line">                values.add(getAggregationValue(each));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 不同的聚集函数不同的merge</span></span><br><span class="line">        entry.getValue().merge(values);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="GroupByMemoryResultSetMerger-group-by字段与排序字段不一致"><a href="#GroupByMemoryResultSetMerger-group-by字段与排序字段不一致" class="headerlink" title="GroupByMemoryResultSetMerger (group by字段与排序字段不一致)"></a>GroupByMemoryResultSetMerger (group by字段与排序字段不一致)</h4><p><strong>归并逻辑</strong><br>在构造器阶段将所有数据归并，遍历所有数据：</p>
<ol>
<li>将group字段值相同的聚集函数字段进行归并；</li>
<li>将归并过的数据通过排序字段排序到List中，List中的元素代表一行数据;</li>
<li>获取List的迭代器memoryResultSetRows，通过迭代器next()。</li>
</ol>
<p><strong>属性</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupByMemoryResultSetMerger</span> <span class="keyword">extends</span> <span class="title">AbstractMemoryResultSetMerger</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SelectStatement selectStatement;</span><br><span class="line">    <span class="comment">// MemoryResultSetRow 存储归并过的一行数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Iterator&lt;MemoryResultSetRow&gt; memoryResultSetRows;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>构造器</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">GroupByMemoryResultSetMerger</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> Map&lt;String, Integer&gt; labelAndIndexMap, <span class="keyword">final</span> List&lt;ResultSet&gt; resultSets, <span class="keyword">final</span> SelectStatement selectStatement)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(labelAndIndexMap);</span><br><span class="line">    <span class="keyword">this</span>.selectStatement = selectStatement;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    memoryResultSetRows = init(resultSets);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> Iterator&lt;MemoryResultSetRow&gt; <span class="title">init</span><span class="params">(<span class="keyword">final</span> List&lt;ResultSet&gt; resultSets)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="comment">// value代表归并后数据</span></span><br><span class="line">    Map&lt;GroupByValue, MemoryResultSetRow&gt; dataMap = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">1024</span>);</span><br><span class="line">    <span class="comment">// key：group字段值，value：&lt;聚合函数字段，聚合函数信息&gt;</span></span><br><span class="line">    Map&lt;GroupByValue, Map&lt;AggregationSelectItem, AggregationUnit&gt;&gt; aggregationMap = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">1024</span>);</span><br><span class="line">    <span class="comment">// 遍历所有数据</span></span><br><span class="line">    <span class="keyword">for</span> (ResultSet each : resultSets) &#123;</span><br><span class="line">        <span class="keyword">while</span> (each.next()) &#123;</span><br><span class="line">            <span class="comment">// group字段值</span></span><br><span class="line">            GroupByValue groupByValue = <span class="keyword">new</span> GroupByValue(each, selectStatement.getGroupByItems());</span><br><span class="line">            <span class="comment">// GroupByValue 为key是否已经存入dataMap和aggregationMap，没有就初始化存入</span></span><br><span class="line">            initForFirstGroupByValue(each, groupByValue, dataMap, aggregationMap);</span><br><span class="line">            <span class="comment">// 聚集函数字段合并</span></span><br><span class="line">            aggregate(each, groupByValue, aggregationMap);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将归并过的数据aggregationMap更新到dataMap中</span></span><br><span class="line">    setAggregationValueToMemoryRow(dataMap, aggregationMap);</span><br><span class="line">    <span class="comment">// 对归并数据按排序字段排序</span></span><br><span class="line">    List&lt;MemoryResultSetRow&gt; result = getMemoryResultSetRows(dataMap);</span><br><span class="line">    <span class="keyword">if</span> (!result.isEmpty()) &#123;</span><br><span class="line">        setCurrentResultSetRow(result.get(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result.iterator();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initForFirstGroupByValue</span><span class="params">(<span class="keyword">final</span> ResultSet resultSet, <span class="keyword">final</span> GroupByValue groupByValue, <span class="keyword">final</span> Map&lt;GroupByValue, MemoryResultSetRow&gt; dataMap, </span></span></span><br><span class="line"><span class="function"><span class="params">                                        <span class="keyword">final</span> Map&lt;GroupByValue, Map&lt;AggregationSelectItem, AggregationUnit&gt;&gt; aggregationMap)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!dataMap.containsKey(groupByValue)) &#123;</span><br><span class="line">        dataMap.put(groupByValue, <span class="keyword">new</span> MemoryResultSetRow(resultSet));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!aggregationMap.containsKey(groupByValue)) &#123;</span><br><span class="line">        Map&lt;AggregationSelectItem, AggregationUnit&gt; map = Maps.toMap(selectStatement.getAggregationSelectItems(), <span class="keyword">new</span> Function&lt;AggregationSelectItem, AggregationUnit&gt;() &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> AggregationUnit <span class="title">apply</span><span class="params">(<span class="keyword">final</span> AggregationSelectItem input)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> AggregationUnitFactory.create(input.getType());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        aggregationMap.put(groupByValue, map);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">aggregate</span><span class="params">(<span class="keyword">final</span> ResultSet resultSet, <span class="keyword">final</span> GroupByValue groupByValue, <span class="keyword">final</span> Map&lt;GroupByValue, Map&lt;AggregationSelectItem, AggregationUnit&gt;&gt; aggregationMap)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (AggregationSelectItem each : selectStatement.getAggregationSelectItems()) &#123;</span><br><span class="line">        List&lt;Comparable&lt;?&gt;&gt; values = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (each.getDerivedAggregationSelectItems().isEmpty()) &#123;</span><br><span class="line">            values.add(getAggregationValue(resultSet, each));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (AggregationSelectItem derived : each.getDerivedAggregationSelectItems()) &#123;</span><br><span class="line">                values.add(getAggregationValue(resultSet, derived));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// groupByValue相等的行的聚合函数字段（each）归并</span></span><br><span class="line">        aggregationMap.get(groupByValue).get(each).merge(values);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>next()方法</strong><br>执行迭代器的next()方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">next</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (memoryResultSetRows.hasNext()) &#123;</span><br><span class="line">        setCurrentResultSetRow(memoryResultSetRows.next());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Mysql分页归并-LimitDecoratorResultSetMerger"><a href="#Mysql分页归并-LimitDecoratorResultSetMerger" class="headerlink" title="Mysql分页归并(LimitDecoratorResultSetMerger)"></a>Mysql分页归并(LimitDecoratorResultSetMerger)</h3><p>LimitDecoratorResultSetMerger是个包装类，可以包装任意归并处理类。</p>
<p>LimitDecoratorResultSetMerger处理分页逻辑是在构造器时调用Offset次被包装的ResultSetMerger对象的next()跳过对应行数据；取数据时通过自身的next()方法限制获取的数据条数。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LimitDecoratorResultSetMerger</span> <span class="keyword">extends</span> <span class="title">AbstractDecoratorResultSetMerger</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Limit limit;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> skipAll;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> rowNumber;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LimitDecoratorResultSetMerger</span><span class="params">(<span class="keyword">final</span> ResultSetMerger resultSetMerger, <span class="keyword">final</span> Limit limit)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(resultSetMerger);</span><br><span class="line">        <span class="keyword">this</span>.limit = limit;</span><br><span class="line">        <span class="comment">// 直接next() Offset次跳过</span></span><br><span class="line">        skipAll = skipOffset();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">skipOffset</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; limit.getOffsetValue(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!getResultSetMerger().next()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        rowNumber = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">next</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (skipAll) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (limit.getRowCountValue() &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> getResultSetMerger().next();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 限制总条数</span></span><br><span class="line">        <span class="keyword">return</span> ++rowNumber &lt;= limit.getRowCountValue() &amp;&amp; getResultSetMerger().next();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://shardingsphere.io/document/legacy/2.x/cn/02-guide/concepts/" target="_blank" rel="noopener">核心概念</a><br><a href="https://blog.csdn.net/yanyan19880509/article/details/78108468" target="_blank" rel="noopener">sharding-jdbc分库分表规则(2)-多表查询</a></p>
</div><div class="tags"><a href="/tags/分库分表/">分库分表</a><a href="/tags/Java/">Java</a><a href="/tags/sharding-jdbc/">sharding-jdbc</a></div><div class="post-nav"><a class="pre" href="/2018/02/24/sharding-jdbc/">分库分表sharding-jdbc源码解析</a><a class="next" href="/2017/07/10/LinkedHashMap解析/">LinkedHashMap解析</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="https://SvizzerChow.github.io"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Netty/">Netty</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Sentinel/">Sentinel</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/redis/">redis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/sharding-jdbc/">sharding-jdbc</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/分布式/">分布式</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/并发/">并发</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据库/">数据库</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法/">算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/线程池/">线程池</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/网络/">网络</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/虚拟机/">虚拟机</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/TCP/" style="font-size: 15px;">TCP</a> <a href="/tags/BASE理论/" style="font-size: 15px;">BASE理论</a> <a href="/tags/虚拟机/" style="font-size: 15px;">虚拟机</a> <a href="/tags/JavaAgent/" style="font-size: 15px;">JavaAgent</a> <a href="/tags/集合/" style="font-size: 15px;">集合</a> <a href="/tags/可见性/" style="font-size: 15px;">可见性</a> <a href="/tags/内存模型/" style="font-size: 15px;">内存模型</a> <a href="/tags/MESI/" style="font-size: 15px;">MESI</a> <a href="/tags/volatile/" style="font-size: 15px;">volatile</a> <a href="/tags/MySQL/" style="font-size: 15px;">MySQL</a> <a href="/tags/网络/" style="font-size: 15px;">网络</a> <a href="/tags/Netty/" style="font-size: 15px;">Netty</a> <a href="/tags/channel/" style="font-size: 15px;">channel</a> <a href="/tags/ServerBootstrap/" style="font-size: 15px;">ServerBootstrap</a> <a href="/tags/NioEventLoop/" style="font-size: 15px;">NioEventLoop</a> <a href="/tags/启动/" style="font-size: 15px;">启动</a> <a href="/tags/线程模型/" style="font-size: 15px;">线程模型</a> <a href="/tags/读写事件/" style="font-size: 15px;">读写事件</a> <a href="/tags/http/" style="font-size: 15px;">http</a> <a href="/tags/沾包/" style="font-size: 15px;">沾包</a> <a href="/tags/拆包/" style="font-size: 15px;">拆包</a> <a href="/tags/内存/" style="font-size: 15px;">内存</a> <a href="/tags/NIO/" style="font-size: 15px;">NIO</a> <a href="/tags/限流/" style="font-size: 15px;">限流</a> <a href="/tags/降级/" style="font-size: 15px;">降级</a> <a href="/tags/熔断/" style="font-size: 15px;">熔断</a> <a href="/tags/Sentinel/" style="font-size: 15px;">Sentinel</a> <a href="/tags/源码解析/" style="font-size: 15px;">源码解析</a> <a href="/tags/CAP理论/" style="font-size: 15px;">CAP理论</a> <a href="/tags/原子性/" style="font-size: 15px;">原子性</a> <a href="/tags/long/" style="font-size: 15px;">long</a> <a href="/tags/double/" style="font-size: 15px;">double</a> <a href="/tags/并发/" style="font-size: 15px;">并发</a> <a href="/tags/redis/" style="font-size: 15px;">redis</a> <a href="/tags/NoSQL/" style="font-size: 15px;">NoSQL</a> <a href="/tags/sentinel/" style="font-size: 15px;">sentinel</a> <a href="/tags/zookeeper/" style="font-size: 15px;">zookeeper</a> <a href="/tags/分布式锁/" style="font-size: 15px;">分布式锁</a> <a href="/tags/数据库/" style="font-size: 15px;">数据库</a> <a href="/tags/分库分表/" style="font-size: 15px;">分库分表</a> <a href="/tags/io/" style="font-size: 15px;">io</a> <a href="/tags/同步/" style="font-size: 15px;">同步</a> <a href="/tags/异步/" style="font-size: 15px;">异步</a> <a href="/tags/线程池/" style="font-size: 15px;">线程池</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/Excutors/" style="font-size: 15px;">Excutors</a> <a href="/tags/多线程/" style="font-size: 15px;">多线程</a> <a href="/tags/FutureTask/" style="font-size: 15px;">FutureTask</a> <a href="/tags/ThreadPoolExecutor/" style="font-size: 15px;">ThreadPoolExecutor</a> <a href="/tags/ScheduledThreadPoolExecutor/" style="font-size: 15px;">ScheduledThreadPoolExecutor</a> <a href="/tags/缓存/" style="font-size: 15px;">缓存</a> <a href="/tags/AbstractExecutorService/" style="font-size: 15px;">AbstractExecutorService</a> <a href="/tags/缓存行/" style="font-size: 15px;">缓存行</a> <a href="/tags/轮询/" style="font-size: 15px;">轮询</a> <a href="/tags/算法/" style="font-size: 15px;">算法</a> <a href="/tags/Spring/" style="font-size: 15px;">Spring</a> <a href="/tags/sharding-jdbc/" style="font-size: 15px;">sharding-jdbc</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/03/12/Netty之旅25PoolSubpage/">Netty解析二十三：Netty内存分配PoolSubpage</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/06/Netty之旅24PoolChunk/">Netty解析二十二：Netty内存分配PoolChunk</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/05/Netty之旅23内存分配模型/">Netty解析二十一：Netty内存分配模型</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/03/同步异步和阻塞非阻塞/">同步/异步与阻塞/非阻塞</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/02/Netty之旅22Netty沾包拆包/">Netty解析二十：Netty中的拆包沾包处理</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/01/TCP协议如何保证可靠性/">TCP协议如何保证可靠性</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/05/Netty之旅21Netty中的buffer/">Netty解析十九：Netty中的buffer</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/04/Netty之旅20服务器端http请求读写流程/">Netty解析十八：Netty服务器端读写事件流程</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/21/常用线程池区分/">Executors常用线程池区分</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/17/Netty之旅19线程模型/">Netty解析十七：Netty线程模型</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2017-2020 <a href="/." rel="nofollow">SvizzerChow's Blog.</a><a rel="nofollow" target="_blank" href="http://www.beian.miit.gov.cn"> 浙ICP备18053179号</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>