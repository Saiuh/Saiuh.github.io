<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="我的个人博客"><title>Sentinel原理十:FlowSlot | SvizzerChow's Blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Sentinel原理十:FlowSlot</h1><a id="logo" href="/.">SvizzerChow's Blog</a><p class="description">Leaning</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Sentinel原理十:FlowSlot</h1><div class="post-meta">Oct 19, 2019<span> | </span><span class="category"><a href="/categories/Sentinel/">Sentinel</a></span></div><div class="post-content"><p><meta name="referrer" content="no-referrer"></p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>FlowSlot 处于 AuthoritySlot 节点后面，负责处理流量的校验，是限流的核心。</p>
<a id="more"></a>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><h3 id="entry-方法"><a href="#entry-方法" class="headerlink" title="entry() 方法"></a>entry() 方法</h3><p>FlowRule 限流规则校验，具体校验由FlowRuleChecker处理<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">entry</span><span class="params">(Context context, ResourceWrapper resourceWrapper, DefaultNode node, <span class="keyword">int</span> count,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">boolean</span> prioritized, Object... args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    checkFlow(resourceWrapper, context, node, count, prioritized);</span><br><span class="line"></span><br><span class="line">    fireEntry(context, resourceWrapper, node, count, prioritized, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">checkFlow</span><span class="params">(ResourceWrapper resource, Context context, DefaultNode node, <span class="keyword">int</span> count, <span class="keyword">boolean</span> prioritized)</span> <span class="keyword">throws</span> BlockException </span>&#123;</span><br><span class="line">    <span class="comment">// Flow rule map cannot be null.</span></span><br><span class="line">    Map&lt;String, List&lt;FlowRule&gt;&gt; flowRules = FlowRuleManager.getFlowRuleMap();</span><br><span class="line"></span><br><span class="line">    List&lt;FlowRule&gt; rules = flowRules.get(resource.getName());</span><br><span class="line">    <span class="keyword">if</span> (rules != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (FlowRule rule : rules) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!canPassCheck(rule, context, node, count, prioritized)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> FlowException(rule.getLimitApp(), rule);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">canPassCheck</span><span class="params">(FlowRule rule, Context context, DefaultNode node, <span class="keyword">int</span> count, <span class="keyword">boolean</span> prioritized)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> FlowRuleChecker.passCheck(rule, context, node, count, prioritized);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="FlowRuleChecker"><a href="#FlowRuleChecker" class="headerlink" title="FlowRuleChecker"></a>FlowRuleChecker</h3><h4 id="规则校验入口-passCheck"><a href="#规则校验入口-passCheck" class="headerlink" title="规则校验入口 passCheck()"></a>规则校验入口 passCheck()</h4><ol>
<li>如果没有设置limitApp，则直接返回true；</li>
<li>如果开启了集群模式，则调用集群校验方法 passClusterCheck()；不然使用 passLocalCheck()。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">passCheck</span><span class="params">(<span class="comment">/*@NonNull*/</span> FlowRule rule, Context context, DefaultNode node, <span class="keyword">int</span> acquireCount,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">boolean</span> prioritized)</span> </span>&#123;</span><br><span class="line">    String limitApp = rule.getLimitApp();</span><br><span class="line">    <span class="keyword">if</span> (limitApp == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 集群模式</span></span><br><span class="line">    <span class="keyword">if</span> (rule.isClusterMode()) &#123;</span><br><span class="line">        <span class="keyword">return</span> passClusterCheck(rule, context, node, acquireCount, prioritized);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 非集群模式</span></span><br><span class="line">    <span class="keyword">return</span> passLocalCheck(rule, context, node, acquireCount, prioritized);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="非集群模式校验-passLocalCheck"><a href="#非集群模式校验-passLocalCheck" class="headerlink" title="非集群模式校验 passLocalCheck()"></a>非集群模式校验 passLocalCheck()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">passLocalCheck</span><span class="params">(FlowRule rule, Context context, DefaultNode node, <span class="keyword">int</span> acquireCount,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      <span class="keyword">boolean</span> prioritized)</span> </span>&#123;</span><br><span class="line">    Node selectedNode = selectNodeByRequesterAndStrategy(rule, context, node);</span><br><span class="line">    <span class="keyword">if</span> (selectedNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 执行rule的</span></span><br><span class="line">    <span class="keyword">return</span> rule.getRater().canPass(selectedNode, acquireCount, prioritized);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>核心是从rule中获取rater执行canPass方法（<strong>规则</strong>）。</p>
<p>getRater：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TrafficShapingController <span class="title">getRater</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> controller;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>getRater() 返回的是 TrafficShapingController 的实现类，这个是由 rule.setGrade 决定的</p>
<p>初始化过程：</p>
<ol>
<li>首先配置Grade，例如rule.setGrade(RuleConstant.<strong>FLOW_GRADE_QPS</strong>);</li>
<li><p>将 rule交由FlowRuleManager管理</p>
<blockquote>
<p>com.alibaba.csp.sentinel.slots.block.flow.FlowRuleManager#loadRules -&gt;<br>com.alibaba.csp.sentinel.property.DynamicSentinelProperty#updateValue -&gt;<br>com.alibaba.csp.sentinel.slots.block.flow.FlowRuleManager.FlowPropertyListener#configUpdate -&gt;<br>com.alibaba.csp.sentinel.slots.block.flow.FlowRuleUtil#buildFlowRuleMap(java.util.List&lt;com.alibaba.csp.sentinel.slots.block.flow.FlowRule&gt;) -&gt;<br>com.alibaba.csp.sentinel.slots.block.flow.FlowRuleUtil#buildFlowRuleMap(java.util.List&lt;com.alibaba.csp.sentinel.slots.block.flow.FlowRule&gt;, com.alibaba.csp.sentinel.util.function.Function&lt;com.alibaba.csp.sentinel.slots.block.flow.FlowRule,K&gt;, com.alibaba.csp.sentinel.util.function.Predicate&lt;com.alibaba.csp.sentinel.slots.block.flow.FlowRule&gt;, boolean) -&gt;<br>com.alibaba.csp.sentinel.slots.block.flow.FlowRuleUtil#generateRater -&gt;<br>com.alibaba.csp.sentinel.slots.block.flow.FlowRule#setRater </p>
</blockquote>
<p>TrafficShapingController 的实现类主要有3个：</p>
</li>
</ol>
<ul>
<li>DefaultController               简单qps限制</li>
<li>RateLimiterController         排队等待（流量更均匀）</li>
<li>WarmUpController             冷启动</li>
</ul>
<p>具体的grade对应的实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> TrafficShapingController <span class="title">generateRater</span><span class="params">(<span class="comment">/*@Valid*/</span> FlowRule rule)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (rule.getGrade() == RuleConstant.FLOW_GRADE_QPS) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (rule.getControlBehavior()) &#123;</span><br><span class="line">            <span class="keyword">case</span> RuleConstant.CONTROL_BEHAVIOR_WARM_UP:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> WarmUpController(rule.getCount(), rule.getWarmUpPeriodSec(),</span><br><span class="line">                                            ColdFactorProperty.coldFactor);</span><br><span class="line">            <span class="keyword">case</span> RuleConstant.CONTROL_BEHAVIOR_RATE_LIMITER:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> RateLimiterController(rule.getMaxQueueingTimeMs(), rule.getCount());</span><br><span class="line">            <span class="keyword">case</span> RuleConstant.CONTROL_BEHAVIOR_WARM_UP_RATE_LIMITER:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> WarmUpRateLimiterController(rule.getCount(), rule.getWarmUpPeriodSec(),</span><br><span class="line">                                                       rule.getMaxQueueingTimeMs(), ColdFactorProperty.coldFactor);</span><br><span class="line">            <span class="keyword">case</span> RuleConstant.CONTROL_BEHAVIOR_DEFAULT:</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="comment">// Default mode or unknown mode: default traffic shaping controller (fast-reject).</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DefaultController(rule.getCount(), rule.getGrade());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="DefaultController"><a href="#DefaultController" class="headerlink" title="DefaultController"></a>DefaultController</h5><p>根据grade的类型决定canPass时是累加线程数还是QPS.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultController</span> <span class="keyword">implements</span> <span class="title">TrafficShapingController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_AVG_USED_TOKENS = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> count;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> grade;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DefaultController</span><span class="params">(<span class="keyword">double</span> count, <span class="keyword">int</span> grade)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.count = count;</span><br><span class="line">        <span class="keyword">this</span>.grade = grade;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPass</span><span class="params">(Node node, <span class="keyword">int</span> acquireCount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> canPass(node, acquireCount, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPass</span><span class="params">(Node node, <span class="keyword">int</span> acquireCount, <span class="keyword">boolean</span> prioritized)</span> </span>&#123;\</span><br><span class="line">        <span class="comment">// 根据grade的类型决定canPass时是累加线程数还是QPS.</span></span><br><span class="line">        <span class="keyword">int</span> curCount = avgUsedTokens(node);</span><br><span class="line">        <span class="comment">// 如果已经超过当前时间窗格的通过数上限了</span></span><br><span class="line">        <span class="keyword">if</span> (curCount + acquireCount &gt; count) &#123;</span><br><span class="line">            <span class="comment">// 有优先且grade为FLOW_GRADE_QPS</span></span><br><span class="line">            <span class="keyword">if</span> (prioritized &amp;&amp; grade == RuleConstant.FLOW_GRADE_QPS) &#123;</span><br><span class="line">                <span class="keyword">long</span> currentTime;</span><br><span class="line">                <span class="keyword">long</span> waitInMs;</span><br><span class="line">                currentTime = TimeUtil.currentTimeMillis();</span><br><span class="line">                <span class="comment">// 尝试借用后续时间窗格的通过数，返回等待时间</span></span><br><span class="line">                waitInMs = node.tryOccupyNext(currentTime, acquireCount, count);</span><br><span class="line">                <span class="comment">// 没有达到最大等待时间</span></span><br><span class="line">                <span class="keyword">if</span> (waitInMs &lt; OccupyTimeoutProperty.getOccupyTimeout()) &#123;</span><br><span class="line">                    <span class="comment">// 等待</span></span><br><span class="line">                    node.addWaitingRequest(currentTime + waitInMs, acquireCount);</span><br><span class="line">                    node.addOccupiedPass(acquireCount);</span><br><span class="line">                    sleep(waitInMs);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// PriorityWaitException indicates that the request will pass after waiting for &#123;@link @waitInMs&#125;.</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> PriorityWaitException(waitInMs);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">avgUsedTokens</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> DEFAULT_AVG_USED_TOKENS;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> grade == RuleConstant.FLOW_GRADE_THREAD ? node.curThreadNum() : (<span class="keyword">int</span>)(node.passQps());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(<span class="keyword">long</span> timeMillis)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(timeMillis);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// Ignore.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="WarmUpController"><a href="#WarmUpController" class="headerlink" title="WarmUpController"></a>WarmUpController</h5><p><a href="https://github.com/alibaba/Sentinel/wiki/%E9%99%90%E6%B5%81---%E5%86%B7%E5%90%AF%E5%8A%A8" target="_blank" rel="noopener">https://github.com/alibaba/Sentinel/wiki/%E9%99%90%E6%B5%81—%E5%86%B7%E5%90%AF%E5%8A%A8</a></p>
<blockquote>
<p>Warm Up（<code>RuleConstant.CONTROL_BEHAVIOR_WARM_UP</code>）方式，即预热/冷启动方式。当系统长期处于低水位的情况下，当流量突然增加时，直接把系统拉升到高水位可能瞬间把系统压垮。通过”冷启动”，让通过的流量缓慢增加，在一定时间内逐渐增加到阈值上限，给冷系统一个预热的时间，避免冷系统被压垮。<br>这个场景主要用于启动需要额外开销的场景，例如建立数据库连接等。<br>它的实现是在 <a href="https://github.com/google/guava/blob/master/guava/src/com/google/common/util/concurrent/SmoothRateLimiter.java" target="_blank" rel="noopener">Guava</a> 的算法的基础上实现的。然而，和 Guava 的场景不同，Guava 的场景主要用于调节请求的间隔，即 <a href="https://en.wikipedia.org/wiki/Leaky_bucket" target="_blank" rel="noopener">Leaky Bucket</a>，而 Sentinel 则主要用于控制每秒的 QPS，即我们满足每秒通过的 QPS 即可，我们不需要关注每个请求的间隔，换言之，我们更像一个 <a href="https://en.wikipedia.org/wiki/Token_bucket" target="_blank" rel="noopener">Token Bucket</a>。<br>我们用桶里剩余的令牌来量化系统的使用率。假设系统每秒的处理能力为 b,系统每处理一个请求，就从桶中取走一个令牌；每秒这个令牌桶会自动掉落b个令牌。令牌桶越满，则说明系统的利用率越低；当令牌桶里的令牌高于某个阈值之后，我们称之为令牌桶”饱和”。<br>当令牌桶饱和的时候，基于 Guava 的计算上，我们可以推出下面的公式:<br>rate(c)=m*c+ coldrate</p>
<p>其中，rate 为当前请求和上一个请求的间隔时间，而 rate 是和令牌桶中的高于阈值的令牌数量成线形关系的。cold rate 则为当桶满的时候，请求和请求的最大间隔。通常是 <code>coldFactor * rate(stable)</code>。</p>
</blockquote>
<p>简单的配置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FlowRule rule = <span class="keyword">new</span> FlowRule();</span><br><span class="line">rule.setResource(resourceName);</span><br><span class="line">rule.setCount(<span class="number">20</span>);</span><br><span class="line">rule.setGrade(RuleConstant.GRADE_QPS);</span><br><span class="line">rule.setLimitApp(<span class="string">"default"</span>);</span><br><span class="line">rule.setControlBehavior(RuleConstant.CONTROL_BEHAVIOR_WARM_UP); <span class="comment">// 冷启动</span></span><br><span class="line">rule.setWarmUpPeriodSec(<span class="number">10</span>); <span class="comment">// 系统进入稳定状态的时间（即预热时长）</span></span><br></pre></td></tr></table></figure>
<p>对warmUpPeriodInSec秒内的总流量进行限流为coldFactor - 1分之一</p>
<p>源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WarmUpController</span> <span class="keyword">implements</span> <span class="title">TrafficShapingController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">double</span> count;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> coldFactor;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> warningToken = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxToken;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">double</span> slope;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> AtomicLong storedTokens = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">protected</span> AtomicLong lastFilledTime = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WarmUpController</span><span class="params">(<span class="keyword">double</span> count, <span class="keyword">int</span> warmUpPeriodInSec, <span class="keyword">int</span> coldFactor)</span> </span>&#123;</span><br><span class="line">        construct(count, warmUpPeriodInSec, coldFactor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WarmUpController</span><span class="params">(<span class="keyword">double</span> count, <span class="keyword">int</span> warmUpPeriodInSec)</span> </span>&#123;</span><br><span class="line">        construct(count, warmUpPeriodInSec, <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// count最大限流数，warmUpPeriodInSec启动时长，coldFactor 冷启动阈值</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">construct</span><span class="params">(<span class="keyword">double</span> count, <span class="keyword">int</span> warmUpPeriodInSec, <span class="keyword">int</span> coldFactor)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (coldFactor &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Cold factor should be larger than 1"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.count = count;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.coldFactor = coldFactor;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// thresholdPermits = 0.5 * warmupPeriod / stableInterval.</span></span><br><span class="line">        <span class="comment">// warningToken = 100;</span></span><br><span class="line">        <span class="comment">// 警戒线</span></span><br><span class="line">        <span class="comment">// 对warmUpPeriodInSec秒内的总流量进行限流为coldFactor - 1分之一</span></span><br><span class="line">        warningToken = (<span class="keyword">int</span>)(warmUpPeriodInSec * count) / (coldFactor - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// / maxPermits = thresholdPermits + 2 * warmupPeriod /</span></span><br><span class="line">        <span class="comment">// (stableInterval + coldInterval)</span></span><br><span class="line">        <span class="comment">// maxToken = 200</span></span><br><span class="line">        <span class="comment">// 最大上限 = 警戒线+2倍warmUpPeriodInSec秒内的总流量的coldFactor+1分之一</span></span><br><span class="line">        maxToken = warningToken + (<span class="keyword">int</span>)(<span class="number">2</span> * warmUpPeriodInSec * count / (<span class="number">1.0</span> + coldFactor));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// slope</span></span><br><span class="line">        <span class="comment">// slope = (coldIntervalMicros - stableIntervalMicros) / (maxPermits</span></span><br><span class="line">        <span class="comment">// - thresholdPermits);</span></span><br><span class="line">        <span class="comment">// 计算斜率</span></span><br><span class="line">        slope = (coldFactor - <span class="number">1.0</span>) / count / (maxToken - warningToken);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPass</span><span class="params">(Node node, <span class="keyword">int</span> acquireCount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> canPass(node, acquireCount, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPass</span><span class="params">(Node node, <span class="keyword">int</span> acquireCount, <span class="keyword">boolean</span> prioritized)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> passQps = (<span class="keyword">long</span>) node.passQps();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> previousQps = (<span class="keyword">long</span>) node.previousPassQps();</span><br><span class="line">        syncToken(previousQps);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开始计算它的斜率</span></span><br><span class="line">        <span class="comment">// 如果进入了警戒线，开始调整他的qps</span></span><br><span class="line">        <span class="keyword">long</span> restToken = storedTokens.get();</span><br><span class="line">        <span class="keyword">if</span> (restToken &gt;= warningToken) &#123;</span><br><span class="line">            <span class="keyword">long</span> aboveToken = restToken - warningToken;</span><br><span class="line">            <span class="comment">// 消耗的速度要比warning快，但是要比慢</span></span><br><span class="line">            <span class="comment">// current interval = restToken*slope+1/count</span></span><br><span class="line">            <span class="keyword">double</span> warningQps = Math.nextUp(<span class="number">1.0</span> / (aboveToken * slope + <span class="number">1.0</span> / count));</span><br><span class="line">            <span class="keyword">if</span> (passQps + acquireCount &lt;= warningQps) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (passQps + acquireCount &lt;= count) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">syncToken</span><span class="params">(<span class="keyword">long</span> passQps)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> currentTime = TimeUtil.currentTimeMillis();</span><br><span class="line">        currentTime = currentTime - currentTime % <span class="number">1000</span>;</span><br><span class="line">        <span class="keyword">long</span> oldLastFillTime = lastFilledTime.get();</span><br><span class="line">        <span class="keyword">if</span> (currentTime &lt;= oldLastFillTime) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> oldValue = storedTokens.get();</span><br><span class="line">        <span class="keyword">long</span> newValue = coolDownTokens(currentTime, passQps);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (storedTokens.compareAndSet(oldValue, newValue)) &#123;</span><br><span class="line">            <span class="keyword">long</span> currentValue = storedTokens.addAndGet(<span class="number">0</span> - passQps);</span><br><span class="line">            <span class="keyword">if</span> (currentValue &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                storedTokens.set(<span class="number">0L</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            lastFilledTime.set(currentTime);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当前的token = 时间* count / 1000</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">coolDownTokens</span><span class="params">(<span class="keyword">long</span> currentTime, <span class="keyword">long</span> passQps)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> oldValue = storedTokens.get();</span><br><span class="line">        <span class="keyword">long</span> newValue = oldValue;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加令牌的判断前提条件:</span></span><br><span class="line">        <span class="comment">// 当令牌的消耗程度远远低于警戒线的时候</span></span><br><span class="line">        <span class="keyword">if</span> (oldValue &lt; warningToken) &#123;</span><br><span class="line">            newValue = (<span class="keyword">long</span>)(oldValue + (currentTime - lastFilledTime.get()) * count / <span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldValue &gt; warningToken) &#123;</span><br><span class="line">            <span class="keyword">if</span> (passQps &lt; (<span class="keyword">int</span>)count / coldFactor) &#123;</span><br><span class="line">                newValue = (<span class="keyword">long</span>)(oldValue + (currentTime - lastFilledTime.get()) * count / <span class="number">1000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.min(newValue, maxToken);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="RateLimiterController"><a href="#RateLimiterController" class="headerlink" title="RateLimiterController"></a>RateLimiterController</h5><p>排队等待</p>
<ol>
<li>计算通过acquireCount个请求需要花费的时间间隔；</li>
<li>计算当前时间之后还要等待多久waitTime；</li>
<li>如果waitTime没有大于最大等待时间maxQueueingTimeMs，则sleep(waitTime)。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RateLimiterController</span> <span class="keyword">implements</span> <span class="title">TrafficShapingController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> maxQueueingTimeMs;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">double</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicLong latestPassedTime = <span class="keyword">new</span> AtomicLong(-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RateLimiterController</span><span class="params">(<span class="keyword">int</span> timeOut, <span class="keyword">double</span> count)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.maxQueueingTimeMs = timeOut;</span><br><span class="line">        <span class="keyword">this</span>.count = count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPass</span><span class="params">(Node node, <span class="keyword">int</span> acquireCount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> canPass(node, acquireCount, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPass</span><span class="params">(Node node, <span class="keyword">int</span> acquireCount, <span class="keyword">boolean</span> prioritized)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Pass when acquire count is less or equal than 0.</span></span><br><span class="line">        <span class="keyword">if</span> (acquireCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Reject when count is less or equal than 0.</span></span><br><span class="line">        <span class="comment">// Otherwise,the costTime will be max of long and waitTime will overflow in some cases.</span></span><br><span class="line">        <span class="keyword">if</span> (count &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> currentTime = TimeUtil.currentTimeMillis();</span><br><span class="line">        <span class="comment">// Calculate the interval between every two requests.</span></span><br><span class="line">        <span class="comment">// 计算通过acquireCount个请求需要花费的时间间隔</span></span><br><span class="line">        <span class="keyword">long</span> costTime = Math.round(<span class="number">1.0</span> * (acquireCount) / count * <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Expected pass time of this request.</span></span><br><span class="line">        <span class="comment">// 这些请求通过的时间</span></span><br><span class="line">        <span class="keyword">long</span> expectedTime = costTime + latestPassedTime.get();</span><br><span class="line">		<span class="comment">// 直接通过</span></span><br><span class="line">        <span class="keyword">if</span> (expectedTime &lt;= currentTime) &#123;</span><br><span class="line">            <span class="comment">// Contention may exist here, but it's okay.</span></span><br><span class="line">            latestPassedTime.set(currentTime);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 计算等待时间</span></span><br><span class="line">            <span class="comment">// Calculate the time to wait.</span></span><br><span class="line">            <span class="keyword">long</span> waitTime = costTime + latestPassedTime.get() - TimeUtil.currentTimeMillis();</span><br><span class="line">            <span class="comment">// 如果等待时间大于最大等待时间则返回false</span></span><br><span class="line">            <span class="keyword">if</span> (waitTime &gt; maxQueueingTimeMs) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">long</span> oldTime = latestPassedTime.addAndGet(costTime);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    waitTime = oldTime - TimeUtil.currentTimeMillis();</span><br><span class="line">                    <span class="keyword">if</span> (waitTime &gt; maxQueueingTimeMs) &#123;</span><br><span class="line">                        latestPassedTime.addAndGet(-costTime);</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// in race condition waitTime may &lt;= 0</span></span><br><span class="line">                    <span class="comment">// sleep相应的时间</span></span><br><span class="line">                    <span class="keyword">if</span> (waitTime &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        Thread.sleep(waitTime);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="集群模式校验-passClusterCheck"><a href="#集群模式校验-passClusterCheck" class="headerlink" title="集群模式校验 passClusterCheck()"></a>集群模式校验 passClusterCheck()</h4><ol>
<li>获取TokenService对象；</li>
<li>如果获取不到则走3，不然走4；</li>
<li>如果fallbackToLocalWhenFail为true则走本地校验，不然直接通过；</li>
<li>通过TokenService的requestToken方法获取限流判断结果；</li>
<li>使用applyTokenResult方法解析返回的结果，根据结果判断是通过/不通过/等待/走降级到本地；<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">passClusterCheck</span><span class="params">(FlowRule rule, Context context, DefaultNode node, <span class="keyword">int</span> acquireCount,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        <span class="keyword">boolean</span> prioritized)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 令牌服务</span></span><br><span class="line">        TokenService clusterService = pickClusterService();</span><br><span class="line">        <span class="comment">// 获取不到令牌服务则降级到本地处理</span></span><br><span class="line">        <span class="keyword">if</span> (clusterService == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> fallbackToLocalOrPass(rule, context, node, acquireCount, prioritized);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> flowId = rule.getClusterConfig().getFlowId();</span><br><span class="line">        <span class="comment">// 获取令牌结果</span></span><br><span class="line">        TokenResult result = clusterService.requestToken(flowId, acquireCount, prioritized);</span><br><span class="line">        <span class="keyword">return</span> applyTokenResult(result, rule, context, node, acquireCount, prioritized);</span><br><span class="line">        <span class="comment">// If client is absent, then fallback to local mode.</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        RecordLog.warn(<span class="string">"[FlowRuleChecker] Request cluster token unexpected failed"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Fallback to local flow control when token client or server for this rule is not available.</span></span><br><span class="line">    <span class="comment">// If fallback is not enabled, then directly pass.</span></span><br><span class="line">    <span class="keyword">return</span> fallbackToLocalOrPass(rule, context, node, acquireCount, prioritized);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 降级处理</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">fallbackToLocalOrPass</span><span class="params">(FlowRule rule, Context context, DefaultNode node, <span class="keyword">int</span> acquireCount,</span></span></span><br><span class="line"><span class="function"><span class="params">                                             <span class="keyword">boolean</span> prioritized)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (rule.getClusterConfig().isFallbackToLocalWhenFail()) &#123;</span><br><span class="line">        <span class="keyword">return</span> passLocalCheck(rule, context, node, acquireCount, prioritized);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// The rule won't be activated, just pass.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 处理TokenService的响应</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">applyTokenResult</span><span class="params">(<span class="comment">/*@NonNull*/</span> TokenResult result, FlowRule rule, Context context, DefaultNode node,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                 <span class="keyword">int</span> acquireCount, <span class="keyword">boolean</span> prioritized)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (result.getStatus()) &#123;</span><br><span class="line">        <span class="keyword">case</span> TokenResultStatus.OK:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">case</span> TokenResultStatus.SHOULD_WAIT:</span><br><span class="line">            <span class="comment">// Wait for next tick.</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(result.getWaitInMs());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">case</span> TokenResultStatus.NO_RULE_EXISTS:</span><br><span class="line">        <span class="keyword">case</span> TokenResultStatus.BAD_REQUEST:</span><br><span class="line">        <span class="keyword">case</span> TokenResultStatus.FAIL:</span><br><span class="line">        <span class="keyword">case</span> TokenResultStatus.TOO_MANY_REQUEST:</span><br><span class="line">            <span class="keyword">return</span> fallbackToLocalOrPass(rule, context, node, acquireCount, prioritized);</span><br><span class="line">        <span class="keyword">case</span> TokenResultStatus.BLOCKED:</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="exit-方法"><a href="#exit-方法" class="headerlink" title="exit() 方法"></a>exit() 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exit</span><span class="params">(Context context, ResourceWrapper resourceWrapper, <span class="keyword">int</span> count, Object... args)</span> </span>&#123;</span><br><span class="line">    fireExit(context, resourceWrapper, count, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><div class="tags"><a href="/tags/限流/">限流</a><a href="/tags/降级/">降级</a><a href="/tags/熔断/">熔断</a><a href="/tags/Sentinel/">Sentinel</a><a href="/tags/源码解析/">源码解析</a></div><div class="post-nav"><a class="pre" href="/2019/11/02/Sentinel原理十一DegradeSlot/">Sentinel原理十一:DegradeSlot</a><a class="next" href="/2019/10/15/Sentinel原理九AuthoritySlot/">Sentinel原理九:AuthoritySlot</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="https://SvizzerChow.github.io"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Netty/">Netty</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Sentinel/">Sentinel</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/redis/">redis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/sharding-jdbc/">sharding-jdbc</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/分布式/">分布式</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/并发/">并发</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据库/">数据库</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法/">算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/网络/">网络</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/虚拟机/">虚拟机</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/源码解析/" style="font-size: 15px;">源码解析</a> <a href="/tags/BASE理论/" style="font-size: 15px;">BASE理论</a> <a href="/tags/虚拟机/" style="font-size: 15px;">虚拟机</a> <a href="/tags/JavaAgent/" style="font-size: 15px;">JavaAgent</a> <a href="/tags/集合/" style="font-size: 15px;">集合</a> <a href="/tags/可见性/" style="font-size: 15px;">可见性</a> <a href="/tags/内存模型/" style="font-size: 15px;">内存模型</a> <a href="/tags/MESI/" style="font-size: 15px;">MESI</a> <a href="/tags/volatile/" style="font-size: 15px;">volatile</a> <a href="/tags/MySQL/" style="font-size: 15px;">MySQL</a> <a href="/tags/网络/" style="font-size: 15px;">网络</a> <a href="/tags/Netty/" style="font-size: 15px;">Netty</a> <a href="/tags/channel/" style="font-size: 15px;">channel</a> <a href="/tags/ServerBootstrap/" style="font-size: 15px;">ServerBootstrap</a> <a href="/tags/NioEventLoop/" style="font-size: 15px;">NioEventLoop</a> <a href="/tags/NIO/" style="font-size: 15px;">NIO</a> <a href="/tags/redis/" style="font-size: 15px;">redis</a> <a href="/tags/NoSQL/" style="font-size: 15px;">NoSQL</a> <a href="/tags/限流/" style="font-size: 15px;">限流</a> <a href="/tags/降级/" style="font-size: 15px;">降级</a> <a href="/tags/熔断/" style="font-size: 15px;">熔断</a> <a href="/tags/Sentinel/" style="font-size: 15px;">Sentinel</a> <a href="/tags/CAP理论/" style="font-size: 15px;">CAP理论</a> <a href="/tags/原子性/" style="font-size: 15px;">原子性</a> <a href="/tags/long/" style="font-size: 15px;">long</a> <a href="/tags/double/" style="font-size: 15px;">double</a> <a href="/tags/并发/" style="font-size: 15px;">并发</a> <a href="/tags/sentinel/" style="font-size: 15px;">sentinel</a> <a href="/tags/zookeeper/" style="font-size: 15px;">zookeeper</a> <a href="/tags/分布式锁/" style="font-size: 15px;">分布式锁</a> <a href="/tags/数据库/" style="font-size: 15px;">数据库</a> <a href="/tags/分库分表/" style="font-size: 15px;">分库分表</a> <a href="/tags/多线程/" style="font-size: 15px;">多线程</a> <a href="/tags/线程池/" style="font-size: 15px;">线程池</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/FutureTask/" style="font-size: 15px;">FutureTask</a> <a href="/tags/AbstractExecutorService/" style="font-size: 15px;">AbstractExecutorService</a> <a href="/tags/ThreadPoolExecutor/" style="font-size: 15px;">ThreadPoolExecutor</a> <a href="/tags/ScheduledThreadPoolExecutor/" style="font-size: 15px;">ScheduledThreadPoolExecutor</a> <a href="/tags/缓存/" style="font-size: 15px;">缓存</a> <a href="/tags/缓存行/" style="font-size: 15px;">缓存行</a> <a href="/tags/轮询/" style="font-size: 15px;">轮询</a> <a href="/tags/算法/" style="font-size: 15px;">算法</a> <a href="/tags/Spring/" style="font-size: 15px;">Spring</a> <a href="/tags/sharding-jdbc/" style="font-size: 15px;">sharding-jdbc</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/12/15/Netty之旅17NioEventLoop/">Netty解析十五：NioEventLoop</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/14/Netty之旅16ServerBootstrap/">Netty解析十四：ServerBootstrap</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/10/Netty之旅15ChannelHandlerContext/">Netty解析十三：ChannelHandlerContext</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/09/Netty之旅14ChannelHandler/">Netty解析十二：ChannelHandler</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/08/Netty之旅13ChannelPipeline/">Netty解析十一：ChannelPipeline与DefaultChannelPipeline</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/07/netty之旅12Channel/">Netty解析十：channel与AbstractNioChannel</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/06/volatile几个场景总结/">volatile几个场景总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/05/long和double使用volatile实现原子性/">volatile long/double原子读写原理</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/04/缓存行优化/">缓存行优化</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/03/MESI与内存屏障/">既然有了MESI协议为什么还要volatile来保证可见性</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2017-2020 <a href="/." rel="nofollow">SvizzerChow's Blog.</a><a rel="nofollow" target="_blank" href="http://www.beian.miit.gov.cn"> 浙icp备330500251067号</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>